{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"terminologia/","title":"Terminolog\u00eda","text":"<p>Template = plantilla: c\u00f3digo para generar karaokes en Aegisub.</p> <p>Templater = creador de plantillas: haciendo referencia al script utilizado para la creaci\u00f3n de karaokes.</p> <p>Tags = etiquetas: referente a las etiquetas de control de Texto utilizadas en Aegisub, como por ejemplo {\\bord5\\shad3}.</p> <p>Frame = fotograma: referente a un \u00fanico cuadro de un video en cuesti\u00f3n.</p>"},{"location":"correccion/correccion/","title":"Correcci\u00f3n","text":""},{"location":"edicion/edicion/","title":"Edici\u00f3n","text":"<p>xddddd</p>"},{"location":"encode/encode/","title":"Encode","text":""},{"location":"karaokes/funcion-autotags/","title":"Introducci\u00f3n a la funci\u00f3n personalizada AutoTags y sus variantes com\u00fanmente utilizadas","text":"<p>La funci\u00f3n AutoTags se utiliza para iterar entre dos (grupos de) tags de efectos dentro de un per\u00edodo de tiempo continuo, como cambiar el valor de <code>blur</code> hacia adelante y hacia atr\u00e1s, creando un efecto de parpadeo. Es muy com\u00fan en muchos scripts. Para usar esta funci\u00f3n, primero debes declararla en la l\u00ednea de c\u00f3digo.</p> <pre><code>function AutoTags(Intervalo,Dato1,Dato2)            local RESULTADO=\"\"     local SUERTE = 0     local CONTADOR = 0     local ARREGLO = 0                           local count = math.ceil(line.duration/Intervalo)                         ARREGLO = {Dato1,Dato2}                            for i = 1, count do               CONTADOR = i                            if Dato1 and Dato2 then                     if  CONTADOR%2 ==0 then                                    SUERTE = ARREGLO[1]                                            else                                    SUERTE = ARREGLO[2]                            end                    end                     RESULTADO = RESULTADO ..\"\\\\t(\" ..(i-1)*Intervalo.. \",\" ..i*Intervalo.. \",\\\\\" ..SUERTE..\")\"..\"\"                      end                 return RESULTADO                                     end\n</code></pre> <p></p> <p>Luego, se llama en el template.</p> <p>El uso original de la funci\u00f3n AutoTags ser\u00eda:  <code>AutoTags(duraci\u00f3n del cambio, \"tag1\", \"tag2\")</code> </p> <p>La efecto generado se ver\u00eda as\u00ed: </p> <p>Se puede observar que durante toda la duraci\u00f3n de la palabra, se produce un cambio de ida y vuelta de <code>blur2</code> a <code>blur0</code> y de <code>blur0</code> a <code>blur2</code>. Si deseas utilizar un cambio de ida y vuelta entre dos conjuntos de etiquetas, ten en cuenta que debes utilizar un <code>\\</code> adicional, como en <code>AutoTags(500, \"blur2\\\\fs50\", \"blur0\\\\fs30\")</code>. La introducci\u00f3n de la funci\u00f3n AutoTags en su forma original termina aqu\u00ed.</p> <p>A continuaci\u00f3n, se presentan distintas variantes de AutoTags generadas por diferentes necesidades.</p> <p>Variante 1</p> <pre><code>function AutoTags1(Intervalo,Dato1,Dato2,Pause)  local RESULTADO=\"\"  local SUERTE = 0  local CONTADOR = 0  local ARREGLO = 0  local count = math.ceil(line.duration/(Intervalo+Pause))  ARREGLO = {Dato1,Dato2}  for i = 1, count do          CONTADOR = i          if Dato1 and Dato2 then                  if  CONTADOR%2 ==0 then                  SUERTE = ARREGLO[1]                  else                  SUERTE = ARREGLO[2]                  end          end          RESULTADO = RESULTADO ..\"\\\\t(\" ..(i-1)*(Intervalo+Pause).. \",\" ..i*Intervalo+Pause*(i-1).. \",\\\\\" ..SUERTE..\")\"..\"\"  end  return RESULTADO  end\n</code></pre> <p></p> <p>Se utiliza para lograr un efecto de cambio de ida y vuelta con tiempo de pausa adicional. El cuarto par\u00e1metro adicional, \"Pause\", representa el tiempo de pausa en milisegundos (ms).</p> <p><code>AutoTags1(duraci\u00f3n del cambio, \"tag1\", \"tag2\", tiempo de pausa)</code></p> <p>Variante 2</p> <pre><code>function AutoTags2(Intervalo,Dato1,Dato2,Delay)            local RESULTADO=\"\"     local SUERTE = 0     local CONTADOR = 0      local ARREGLO = Layer                            local count = math.ceil(line.duration/Intervalo)                                         ARREGLO = {Dato1,Dato2}                                          for i = 1, count do               CONTADOR = i                                            if Dato1 and Dato2 then                                             if  CONTADOR%2 ==0 then                                                                    SUERTE = ARREGLO[1]                                            else                                                                    SUERTE = ARREGLO[2]                                            end                            end                                                 RESULTADO = RESULTADO ..\"\\\\t(\" ..(i-1)*Intervalo+Delay.. \",\" ..i*Intervalo+Delay.. \",\\\\\" ..SUERTE.. \")\"..\"\"                                  end                              return RESULTADO                                             end\n</code></pre> <p>Se utiliza para lograr un efecto de cambio de ida y vuelta con retraso (en relaci\u00f3n al tiempo de inicio de la l\u00ednea).  Por ejemplo, se necesita que el efecto de cambio ocurra 1 segundo despu\u00e9s del inicio de la l\u00ednea: <code>AutoTags2(500, \"tag1\", \"tag2\", 1000)</code></p> <p>Variante3</p> <pre><code>function AutoTags3(Intervalo1,Intervalo2,Dato1,Dato2)  local RESULTADO=\"\"                 local SUERTE = 0                 local CONTADOR = 0                 local ARREGLO = 0                               local count = 2*math.ceil(line.duration/(Intervalo1+Intervalo2))            local d=math.ceil((Intervalo2-Intervalo1)/count)  local t={}  ARREGLO = {Dato1,Dato2}                                                      for i = 1, count do                                   CONTADOR = i  t[1]=0  t[i+1]=t[i]+Intervalo1+(i-1)*d  if Dato1 and Dato2 then            if  CONTADOR%2 ==0 then                                                                                        SUERTE = ARREGLO[1]            else                                                                                        SUERTE = ARREGLO[2]                                                        end            end                                                             RESULTADO = RESULTADO ..\"\\\\t(\" ..t[i].. \",\" ..t[i+1].. \",\\\\\" ..SUERTE..\")\"..\"\"                                              end                                          return RESULTADO                                                         end\n</code></pre> <p>AutoTags en forma de una progresi\u00f3n aritm\u00e9tica (con el tiempo de cambio aumentando o disminuyendo).  El efecto de decremento es similar a un temporizador de bomba, volvi\u00e9ndose cada vez m\u00e1s r\u00e1pido. Mientras que el efecto de incremento indica que la velocidad de cambio se vuelve cada vez m\u00e1s lenta.</p> <p><code>AutoTags3(tiempo inicial del cambio, tiempo final del cambio, \"tag1\", \"tag2\")</code> </p> <p>Si <code>tiempo inicial del cambio</code> &gt; <code>tiempo final del cambio</code>, es un efecto de decremento. Si <code>tiempo final del cambio</code> &gt; <code>tiempo inicial del cambio</code>, es un efecto de incremento.</p> <p>El archivo ASS est\u00e1 adjunto: AutoTags.zip</p> <p>Por el momento, solo puedo pensar en estas pocas variantes: progresi\u00f3n geom\u00e9trica, alternancia entre dos conjuntos de tiempos tambi\u00e9n es una buena idea. \u00a1Bienvenidos todos a contribuir! </p>"},{"location":"karaokes/lib-color-0x/","title":"Colorlib","text":"<p>\u00bfAlguna vez has querido crear un degradado en KFX? \u00bfSe siente frustrado por los espacios de color, ya que los degradados RGB rara vez resultan como usted desea? No busque m\u00e1s.</p> <p>Colorlib le da una multitud de \u00fatiles<sup>1</sup> para manipular colores en ASS (y, oye, por qu\u00e9 no fuera de \u00e9l tambi\u00e9n).</p> <p>En esto, \"cadena de color ASS\" se refiere a un valor que podr\u00edas pasar a, por ejemplo, una etiqueta <code>\\c</code>, es decir: <code>&amp;H012345&amp;</code>.</p>"},{"location":"karaokes/lib-color-0x/#interpolacion","title":"Interpolaci\u00f3n","text":"<p>Interpolaci\u00f3n lineal entre dos colores en un espacio de color determinado. Todos los argumentos tienen el mismo formato:</p> <p><code>interp_xxx(t, color_1, color_2)</code></p> <ul> <li><code>t</code>: \"Distancia\" a recorrer, de 0 a 1, ambos inclusive. Un valor de 0 corresponde a <code>color_1</code>, un valor de 1 a <code>color_2</code>. Un valor de 0.5 est\u00e1 a medio camino.</li> <li><code>color_1</code>: color \"inicial</li> <li><code>color_2</code>: color \"Final</li> </ul> <p>Devuelve una cadena de color ASS.</p> <p>Actualmente, se admiten estos cuatro espacios de color:</p> <ul> <li><code>interp_lch</code> - LCh (CIE L*C*h)</li> <li><code>interp_lab</code> - CIELAB (L*a*b*)</li> <li><code>interp_rgb</code> - RGB simple</li> <li><code>interp_xyz</code> - XYZ (CIE 1931 XYZ)</li> </ul> <p>Adem\u00e1s, <code>interp_alpha</code> es una funci\u00f3n con una firma equivalente para los valores alfa de ASS.</p>"},{"location":"karaokes/lib-color-0x/#formateo-del-color","title":"Formateo del color","text":"<p>Formatea valores \"crudos\" en cadenas de color ASS.</p> <p><code>fmt_rgb(r, g, b)</code></p> <ul> <li>Todos los valores entre 0 y 255.</li> </ul> <p><code>fmt_xyz(x, y, z)</code></p> <ul> <li>Todos los valores entre 0 y 1.</li> </ul> <p><code>fmt_lab(l, a, b)</code></p> <ul> <li><code>l</code> entre 0 y 100.</li> <li><code>a</code> y <code>b</code> entre -128 y 127.</li> </ul> <p><code>fmt_lch(l, c, h)</code></p> <ul> <li><code>l</code> entre 0 y 100.</li> <li><code>c</code> y <code>h</code> entre 0 y 360.</li> </ul> <p><code>fmt_alpha(alpha)</code></p> <ul> <li>Espero que se explique por s\u00ed mismo, sobre todo para completar el conjunto. Toma valores entre 0 y 255.</li> </ul>"},{"location":"karaokes/lib-color-0x/#ajuste-del-color","title":"Ajuste del color","text":"<p>Ajusta un color determinado. Actualmente s\u00f3lo soporta operaciones de aclarar/oscurecer. En el momento de escribir esto, la l\u00f3gica de aclarado no funciona correctamente, por lo que algunos colores no alcanzan los extremos deseados. Si es relevante, puedes usar valores fuera del rango \u00b11.</p> <p><code>lighten(color, cantidad)</code></p> <ul> <li>Aclara el color dado (cadena de color ASS) en la cantidad especificada.</li> <li><code>cantidad</code> oscila entre -1 y 1.<ol> <li>0 deja el color sin cambios</li> <li>1 lo hace lo m\u00e1s claro posible (cercano al blanco)</li> <li>-1 hace que sea lo m\u00e1s oscuro (cercano al negro) posible</li> </ol> </li> </ul> <p><code>lighten_complex(x, y, z, cantidad, espacio_color)</code></p> <ul> <li>Como <code>lighten</code>, pero en su lugar toma valores de color sin procesar en lugar de una cadena de color.</li> <li><code>colorspace</code> puede ser <code>rgb</code>, <code>xyz</code>, <code>lch</code> o <code>lab</code> (por defecto).</li> </ul> <ol> <li> <p>no se garantiza la utilidad de dichas funciones\u00a0\u21a9</p> </li> </ol>"},{"location":"karaokes/templater-0x/","title":"Creador de templates de The0x539","text":"<p>Hola, soy el creador de templates de The0x539. Realmente no tengo un nombre en s\u00ed, por lo que The0x539 escribi\u00f3 mis documentos en primera persona como una soluci\u00f3n muy extra\u00f1a. No aparece mucho, as\u00ed que espero que no distraiga demasiado.</p> <p>Si ya tienes experiencia con un creador de templates, muchos aspectos de mi funcionamiento pueden resultarte bastante familiares. Sin embargo, hay algunas diferencias clave en el uso b\u00e1sico que pueden causar confusi\u00f3n al cambiarte. En particular, aunque comparto muchas caracter\u00edsticas con otros creadores de templates, no soy compatible con templates escritos para ellos, o viceversa, aparte de casos incidentales sencillos. En realidad, esto no es nada nuevo: los otros dos principales creadores de templates ya no son compatibles entre s\u00ed, pero parece que merece la pena dejar clara y expl\u00edcita esta incompatibilidad. Cuando se escribe una template, hay que elegir a qu\u00e9 creador de templates dirigirse. Esto ya era as\u00ed antes de que yo llegara.</p>"},{"location":"karaokes/templater-0x/#templates","title":"Templates","text":"<p>Cualquier template razonable consistir\u00e1 en dos cosas, que estos documentos llamar\u00e1n components e input. A continuaci\u00f3n se describir\u00e1n en profundidad cada uno de ellos, pero brevemente, para aquellos que est\u00e9n algo familiarizados con la creaci\u00f3n de templates, un component es una l\u00ednea de subt\u00edtulo marcada con <code>code</code>/<code>template</code>/<code>mixin</code> (m\u00e1s sobre esto \u00faltimo m\u00e1s adelante) en su campo de efecto, y una l\u00ednea input es una marcada con <code>kara</code>. Con algunas excepciones (principalmente <code>code once</code>), la idea detr\u00e1s de ejecutar una template es, para cada l\u00ednea de entrada, \"ejecutar\" cada componente contra esa l\u00ednea (o contra cada char/etc dentro de ella).</p>"},{"location":"karaokes/templater-0x/#input","title":"Input","text":"<p>Input is probably the simpler of the two parts of a template. Simply put, for a typical template, an input line consists of one line of lyrics for a song. The lyrics may include k-timing tags, for use with <code>syl</code>-class components, as well as the standard karaskel hyphen-prefixed inline-fx tags. Details on k-timing are beyond the scope of this document.</p> <p>Importantly, a line of input must have its effect field set to <code>kara</code> (or <code>karaoke</code>). Unlike other templaters, I do not treat a line as input unless it is already explicitly marked as such. This is not only a deliberate design decision, but also (arguably) necessary due to my more advanced conditional execution logic.</p> <p>Input lines' actor fields are very useful for conditional execution purposes. On a basic level, different actor values can be used to denote different parts of a song, applying a different set of components to each. Getting more advanced, a template could be written to have a common <code>template</code> component apply to all the input, but select different <code>mixin</code>s based on parts of the song, perhaps to differ in color but share all other attributes. In its most powerful form, an input line's actor field can be used as a collection of modifiers to mix and match different components on a per-line basis. More on this later.</p>"},{"location":"karaokes/templater-0x/#components","title":"Components","text":"<p>Components are the fun part of making a template. Components come in three varieties: <code>code</code>, <code>template</code>, and <code>mixin</code>. My <code>code</code> and <code>template</code> components are, at a basic level, very similar to those of other templaters, and <code>mixin</code> components are like a more powerful form of karaOK's <code>template lsyl</code> family of components.</p> <p>A component is defined by its effect field, which acts as a space-separated list of tokens. The first token must be <code>code</code>, <code>template</code>, or <code>mixin</code>, depending on which kind of component it is. The second token is the component's class, which is one of the following:</p> Class Description <code>once</code> Runs once at the beginning of template evaluation. Only valid for <code>code</code> components. (<code>template once</code> TBD) <code>line</code> Runs once for each line of input. <code>syl</code> Runs once for each k-timed <code>syl</code> within each line of input. Lines with no k-timing information will be treated as one big syl. <code>word</code> Like <code>syl</code>, but separated by whitespace instead of k-timing tags. <code>char</code> Runs once for each character (currently uses <code>unicode.chars</code>) within each line of input. <p>Further tokens within a component's effect field, if present, are modifiers. More on those later.</p>"},{"location":"karaokes/templater-0x/#code-components","title":"<code>code</code> Components","text":"<p>A <code>code</code> component is simple: running it executes its text as a block of Lua code. Their most common use is <code>code once</code> components that import utility libraries, define helper functions, or set up global constants for use elsewhere in the template. However, the other classes do occasionally prove useful, executing the code on, e.g., a per-line basis.</p>"},{"location":"karaokes/templater-0x/#template-components","title":"<code>template</code> Components","text":"<p>As their name might imply, <code>template</code> components are central to writing a template, as with my predecessors. It is their sole responsibility to generate new lines of output. If there are no <code>template</code> components, no lines will be generated. Generally speaking, running a <code>template</code> component entails evaluating any inline variables or inline expressions in its text, then generating a line of output consisting of the evaluated template text and the piece of text that the component's running against. For example, consider the following simple template and the output it produces based on the given input:</p> <pre><code>template line: {\\placeholder}\ntemplate syl: {\\foo}\nkara: {\\k86}Word{\\k41}less{\\k24}ly {\\k87}watch{\\k33}ing {\\k63}he {\\k66}waits{\\k25} {\\k44}by {\\k22}the {\\k57}win{\\k69}dow\nkara: {\\k36}And {\\k38}won{\\k59}ders{\\k43} {\\k25}at {\\k16}the {\\k40}emp{\\k21}ty {\\k49}place {\\k26}in{\\k85}side\nfx: {\\placeholder}Wordlessly watching he waits by the window\nfx: {\\foo}Word\nfx: {\\foo}less\nfx: {\\foo}ly\nfx: {\\foo}watch\nfx: {\\foo}ing\nfx: {\\foo}he\nfx: {\\foo}waits\nfx: {\\foo}\nfx: {\\foo}by\nfx: {\\foo}the\nfx: {\\foo}win\nfx: {\\foo}dow\nfx: {\\placeholder}And wonders at the empty place inside\nfx: {\\foo}And\nfx: {\\foo}won\nfx: {\\foo}ders\nfx: {\\foo}\nfx: {\\foo}at\nfx: {\\foo}the\nfx: {\\foo}emp\nfx: {\\foo}ty\nfx: {\\foo}place\nfx: {\\foo}in\nfx: {\\foo}side\n</code></pre> <p>Already this is useful for simple song styles, since you can now apply a set of tags to a set of lines, perhaps even with multiple layers, while not having to manually keep everything consistent. Add some inline expressions to generate more complicated tags to each line and things start to get interesting.</p>"},{"location":"karaokes/templater-0x/#mixin-components","title":"<code>mixin</code> Components","text":"<p>Mixins, as a first-class component variety, are my defining feature. They modify the output produced by <code>template</code> components, generally adding tags. If <code>template lsyl</code> from karaOK is unfamiliar to you, consider the following basic demonstration:</p> <pre><code>template line: {\\Tpl}\nmixin line: {\\line}\nmixin syl: {\\syl}\nmixin char: {\\char}\nkara: {\\k86}Word{\\k41}less{\\k24}ly {\\k87}watch{\\k33}ing {\\k63}he {\\k66}waits{\\k25} {\\k44}by {\\k22}the {\\k57}win{\\k69}dow\nkara: {\\k36}And {\\k38}won{\\k59}ders{\\k43} {\\k25}at {\\k16}the {\\k40}emp{\\k21}ty {\\k49}place {\\k26}in{\\k85}side\nfx: {\\Tpl\\line\\syl\\char}W{\\char}o{\\char}r{\\char}d{\\syl\\char}l{\\char}e{\\char}s{\\char}s{\\syl\\char}l{\\char}y{\\char} {\\syl\\char}w{\\char}a{\\char}t{\\char}c{\\char}h{\\syl\\char}i{\\char}n{\\char}g{\\char} {\\syl\\char}h{\\char}e{\\char} {\\syl\\char}w{\\char}a{\\char}i{\\char}t{\\char}s{\\syl\\char} {\\syl\\char}b{\\char}y{\\char} {\\syl\\char}t{\\char}h{\\char}e{\\char} {\\syl\\char}w{\\char}i{\\char}n{\\syl\\char}d{\\char}o{\\char}w\nfx: {\\Tpl\\line\\syl\\char}A{\\char}n{\\char}d{\\char} {\\syl\\char}w{\\char}o{\\char}n{\\syl\\char}d{\\char}e{\\char}r{\\char}s{\\syl\\char} {\\syl\\char}a{\\char}t{\\char} {\\syl\\char}t{\\char}h{\\char}e{\\char} {\\syl\\char}e{\\char}m{\\char}p{\\syl\\char}t{\\char}y{\\char} {\\syl\\char}p{\\char}l{\\char}a{\\char}c{\\char}e{\\char} {\\syl\\char}i{\\char}n{\\syl\\char}s{\\char}i{\\char}d{\\char}e\n</code></pre> <p>Any number of <code>mixin</code> components can \"apply to\" any number of <code>template</code> components using my powerful conditional execution abilities, offering much more expressive templating than the \"name association\" system my predecessors offer.</p> <p>Mixins can be very useful for relying more heavily on <code>template line</code> than is strictly necessary, resulting in cleaner output that's also easier to make sense of. For instance, combining <code>template line</code> with <code>mixin syl</code> allows for simple (read: doesn't involve movement or horizontal scaling) in-line highlight effects, and <code>mixin char</code> can be useful for by-character gradients.</p> <p><code>mixin line</code> is an interesting construct. It goes once at the start of each generated line, like the text of the template it's modifying, but as a mixin, it works as a modifier. Even if the template's class is <code>syl</code>, <code>word</code>, or <code>char</code>, it's appropriate to use <code>mixin line</code> to modify the entire line of output. Combined with conditional execution, this behavior becomes quite useful: - If a song style is largely uniform, but uses different colors for different groups of lines (perhaps color-coded by character), then the common tags could be put in a <code>template</code> that applies to the entire song, and there would be a <code>mixin</code> for each color, with each one set to execute when appropriate (likely using the <code>actor</code> modifier). This could also have been achieved using a sort of lookup table, but it makes for a decent example, and this approach actually scales better when space-separated actors get involved. - If a style has some complicated stuff going on, but there is, for instance, a variety of templates meant to generate a consistent \"glow\" effect, then a mixin can be used to apply the same tags to all \"glow\" output without adding them to each template.</p>"},{"location":"karaokes/templater-0x/#modifiers","title":"Modifiers","text":"<p>In addition to its variety and class, a component's effect field may contain any amount of modifiers, which alter its behavior. Most modifiers allow you to specify the conditions under which a component will execute based on the input or whatever else.</p> <p>If there are multiple different restrictions on a component, then all restrictions must be satisfied for the component to execute. For example, a mixin with the modifiers <code>actor foo actor bar layer 3 layer 5</code> will execute only for lines where ((actor contains <code>foo</code> OR actor contains <code>bar</code>) AND (layer is 3 or layer is 5)).</p>"},{"location":"karaokes/templater-0x/#style","title":"<code>style</code>","text":"<p>By default, a component is \"interested\" in only the style that it is itself set to. This means that it will only execute for input with a matching style. Adding <code>style foo</code> to a template will add <code>foo</code> to its set of interested styles, so it will also execute for input with the <code>foo</code> style. Styles with names containing spaces do not currently work with this modifier.</p>"},{"location":"karaokes/templater-0x/#anystyle","title":"<code>anystyle</code>","text":"<p>Similar to the <code>all</code> modifier in other templaters, this makes the component interested in any style.</p>"},{"location":"karaokes/templater-0x/#actor","title":"<code>actor</code>","text":"<p>Similar to the <code>style</code> modifier, each component has a set of actor values it is \"interested\" in. By default, this set is empty and a component won't look at the input's actor field. Adding one or more <code>actor</code> modifiers will restrict the component to only execute for input with matching actor values.</p> <p>Advanced usage: The actor field of a line of input is treated not as a single string, but as a space-separated list of actors, so input can be given multiple \"actor values\" that the component tries to match. If there is any intersection between the component's set of interested actors and the input's set of actor values, the component will execute.</p>"},{"location":"karaokes/templater-0x/#noactor","title":"<code>noactor</code>","text":"<p>Works basically the same way as <code>actor</code>, but adds to a list of \"disinterested\" actor values for which the component will not execute. Can sort of be said to take \"precedence\" over <code>actor</code>, but that doesn't accurately reflect how these modifiers are implemented.</p>"},{"location":"karaokes/templater-0x/#t_actor","title":"<code>t_actor</code>","text":"<p>Only valid for <code>mixin</code>s. Very similar to <code>actor</code>, but checks the base template the mixin is running on, not the input. For instance, if one has a <code>template</code> that generates triangular particle effects, one could put <code>tri</code> in its actor field and then use <code>t_actor tri</code> to make mixins that only apply to the particles.</p>"},{"location":"karaokes/templater-0x/#no_t_actor","title":"<code>no_t_actor</code>","text":"<p>Given the previous three modifiers, this should be self-explanatory.</p>"},{"location":"karaokes/templater-0x/#sylfx-and-inlinefx","title":"<code>sylfx</code> and <code>inlinefx</code>","text":"<p>Only valid for <code>syl</code> and <code>char</code> components. Another \"interested values\" system, this time for checking the value of the current syllable's <code>syl_fx</code>/<code>inline_fx</code> field. Useful for expressing conditional execution that changes on a per-syl basis.</p>"},{"location":"karaokes/templater-0x/#layer","title":"<code>layer</code>","text":"<p>Only valid for <code>mixin</code>s.</p> <p>Again, similar to <code>style</code> or <code>actor</code>. By default, a mixin is \"interested\" in all layers. This modifier restricts a mixin to only execute for certain layer numbers.</p> <p>When checking the layer number, I look at the output's current layer number. Output lines start with a layer number copied from the <code>template</code> that generated them, but the number may be changed by functions such as <code>relayer</code>. If the layer is changed, I will \"see\" the updated layer number, not the original.</p>"},{"location":"karaokes/templater-0x/#if-and-unless","title":"<code>if</code> and <code>unless</code>","text":"<p>Easily the most powerful conditional execution modifier. Given an <code>if foo</code> modifier, I will look in the Lua environment for a value named <code>foo</code>. When checking whether to execute, I will expect this value to be either a boolean or a function. If it is a function, I will call it (with no arguments) and look at the result. Either way, I then use this value as a predicate to decide whether the component should execute.</p> <p>For <code>if</code>, the component will only execute if the value is <code>true</code>. For <code>unless</code>, the component will only execute if the value is <code>false</code>.</p> <p>At the moment, only one instance of the <code>if</code>/<code>unless</code> modifier is allowed per component.</p> <p><code>cond</code> is an alias for <code>if</code>.</p>"},{"location":"karaokes/templater-0x/#noblank","title":"<code>noblank</code>","text":"<p>Primarily useful for <code>syl</code> and <code>char</code> components. Similar to the <code>noblank</code> modifier in other templaters, but also works for mixins. This is useful for, say, preventing a <code>mixin char</code> component from pointlessly executing for spaces.</p> <p>Components with the <code>noblank</code> modifier will not execute for input whose text is empty or consists entirely of whitespace. Unlike other templaters, this will not filter out syls with zero duration. For that, see <code>nok0</code>.</p>"},{"location":"karaokes/templater-0x/#nok0","title":"<code>nok0</code>","text":"<p>Only valid for <code>syl</code> and <code>char</code> components.</p> <p>Components with this modifier will not execute for syls with zero duration, or chars belonging to such a syl.</p>"},{"location":"karaokes/templater-0x/#keepspace","title":"<code>keepspace</code>","text":"<p>Only valid for <code>template</code>s. Primarily useful for <code>syl</code> and <code>word</code>. By default, just before inserting a line of output into the file, I will trim away any trailing whitespace. The <code>keepspace</code> modifier will disable this behavior for an individual template, should this be desirable for any reason.</p>"},{"location":"karaokes/templater-0x/#nomerge","title":"<code>nomerge</code>","text":"<p>Only valid for <code>template</code>s. By default, just before removing trailing whitespace, I will merge consecutive tag blocks from output lines. This is done using the primitive technique of naively removing <code>}{</code> from the output, so if this breaks anything fancy, the <code>nomerge</code> modifier can disable this behavior.</p>"},{"location":"karaokes/templater-0x/#notext","title":"<code>notext</code>","text":"<p>Only valid for <code>template</code>s. Equivalent to the <code>notext</code> modifier from other templaters. By default, the last step of generating a line (i.e. after running all <code>mixins</code>) is to append the corresponding text from the source line. The <code>notext</code> modifier disables this behavior.</p> <p>Useful when, say, generating particle effects with drawings.</p>"},{"location":"karaokes/templater-0x/#loop","title":"<code>loop</code>","text":"<p>Other templaters support giving a component a <code>loop n</code> modifier, where <code>n</code> is some integer. The component will then execute n times, and the current/maximum loop values can be accessed using <code>j</code> and <code>maxj</code>, available as both Lua variables and inline variables. Loops follow the convention set by Lua, starting at 1 and including the maximum.</p> <p>My implementation of this feature is similar, but I require specifying a name in the modifier, e.g., <code>loop foo 3</code>. The loop count is then accessed using <code>$loop_foo</code> or, in Lua, <code>loopctx.state.foo</code>, and the maximum with <code>$maxloop_foo</code> or <code>loopctx.max.foo</code>. This allows for multiple independent named loops on a single component. Having multiple loops can be very powerful for anything that requires more than one \"dimension\" of repetition, like combining some frame-by-frame effect with a vertical gradient.</p> <p>If there are multiple loops, they will be nested in reverse order of appearance. As a demonstration of this, consider the following example:</p> <pre><code>template line loop foo 2 loop bar 3: {\\foo$loop_foo\\bar$loop_bar}\nkara: {\\k86}Word{\\k41}less{\\k24}ly {\\k87}watch{\\k33}ing {\\k63}he {\\k66}waits{\\k25} {\\k44}by {\\k22}the {\\k57}win{\\k69}dow\nkara: {\\k36}And {\\k38}won{\\k59}ders{\\k43} {\\k25}at {\\k16}the {\\k40}emp{\\k21}ty {\\k49}place {\\k26}in{\\k85}side\nfx: {\\foo1\\bar1}Wordlessly watching he waits by the window\nfx: {\\foo2\\bar1}Wordlessly watching he waits by the window\nfx: {\\foo1\\bar2}Wordlessly watching he waits by the window\nfx: {\\foo2\\bar2}Wordlessly watching he waits by the window\nfx: {\\foo1\\bar3}Wordlessly watching he waits by the window\nfx: {\\foo2\\bar3}Wordlessly watching he waits by the window\nfx: {\\foo1\\bar1}And wonders at the empty place inside\nfx: {\\foo2\\bar1}And wonders at the empty place inside\nfx: {\\foo1\\bar2}And wonders at the empty place inside\nfx: {\\foo2\\bar2}And wonders at the empty place inside\nfx: {\\foo1\\bar3}And wonders at the empty place inside\nfx: {\\foo2\\bar3}And wonders at the empty place inside\n</code></pre> <p>See the <code>incr</code> method in the <code>loopctx</code> class for how this works. Basically, usage of <code>loop</code> is treated as one big loop, where the iteration step entails treating the loopctx as a little-endian list of digits: * Increment the first loop variable. * If this exceeds that loop's maximum value, step forward by resetting it to 1 and incrementing the next loop variable. * If the next loop variable also overflowed, step forward again in the same fashion. Repeat. * If the final loop variable has overflowed, the \"big loop\" is done.</p> <p><code>repeat</code> is an alias for <code>loop</code>.</p> <p>Mixins now support loops! Loop variables for mixins are namespaced separately from their template's loop variables. As inline variables, they are accessed with <code>$mloop_bar</code> and <code>$maxmloop_bar</code>. In Lua, they are accessed from <code>mloopctx</code> instead of <code>loopctx</code>, and the <code>maxmloop</code> function takes the place of <code>maxloop</code>.</p>"},{"location":"karaokes/templater-0x/#prefix","title":"<code>prefix</code>","text":"<p>Only valid for <code>mixin</code>s. Mixin output is usually placed just before the text it's associated with. The <code>prefix</code> modifier instead places it at the beginning of the line, alongside the base <code>template</code> text and any <code>mixin line</code> components. Consider the following example, where one <code>mixin word</code> component has the <code>prefix</code> modifier and one does not:</p> <pre><code>template line: {\\X}\nmixin word prefix: {\\Y(!word.text!)}\nmixin word: {\\Z}\nkara: {\\k86}Word{\\k41}less{\\k24}ly {\\k87}watch{\\k33}ing {\\k63}he {\\k66}waits{\\k25} {\\k44}by {\\k22}the {\\k57}win{\\k69}dow\nkara: {\\k36}And {\\k38}won{\\k59}ders{\\k43} {\\k25}at {\\k16}the {\\k40}emp{\\k21}ty {\\k49}place {\\k26}in{\\k85}side\nfx: {\\X\\Y(Wordlessly )\\Y(watching )\\Y(he )\\Y(waits )\\Y(by )\\Y(the )\\Y(window)\\Z}Wordlessly {\\Z}watching {\\Z}he {\\Z}waits {\\Z}by {\\Z}the {\\Z}window\nfx: {\\X\\Y(And )\\Y(wonders )\\Y(at )\\Y(the )\\Y(empty )\\Y(place )\\Y(inside)\\Z}And {\\Z}wonders {\\Z}at {\\Z}the {\\Z}empty {\\Z}place {\\Z}inside\n</code></pre> <p>This may seem like a fairly strange modifier to offer, but I have it for a fairly specific purpose: using <code>\\t(\\clip)</code> in a <code>mixin syl prefix</code> component to produce behavior similar to <code>\\kf</code>, but with all the flexibility of clips and transforms.</p>"},{"location":"karaokes/templater-0x/#template-execution","title":"Template Execution","text":"<p>TODO</p>"},{"location":"karaokes/templater-0x/#execution-ordersemantics","title":"Execution Order/Semantics","text":"<pre><code>for each line of input:\n    (try to) run all `code line` components\n    (try to) run all `template line` components\n\n    for each word in the line:\n        (try to) run all `code word` components\n        (try to) run all `template word` components\n\n    do the above for syls and chars\n</code></pre> <p>(mixins happen as part of \"running a template\") see the <code>apply_templates</code> function for more details</p> <p>TODO</p>"},{"location":"karaokes/templater-0x/#inline-expressions","title":"Inline Expressions","text":"<p>In a template's text, Lua expressions enclosed in a pair of <code>!</code> will be evaluated, with their result placed in the output text, like <code>!word.text!</code> as used in an earlier example. Unlike other templaters, I will treat <code>nil</code> as an empty string here, which is convenient when writing functions like <code>retime</code> and <code>relayer</code> that are useful for their side effects.</p> <p>Depending on the component being executed, a few tables such as <code>line</code>, <code>syl</code>, <code>word</code>, and/or <code>char</code> will be in scope, and will be populated with information such as <code>.text_stripped</code>, <code>.duration</code>, or <code>.width</code>. More information on common fields can be found here. The stock templater lacks full support for <code>word</code> and <code>char</code> classes, but they are somewhat similar to <code>syl</code>. \"Parent\" items can be accessed where it makes sense, such as <code>char.syl</code> or <code>word.line</code>.</p> <p>I populate these objects with some fields that aren't available in other templaters. Notably, in a <code>syl</code>, the <code>.syl_fx</code> field is similar to the <code>.inline_fx</code> field, but does not \"stick\" to subsequent syls within a line.</p> <p>For example, consider the following line: <code>{\\k86}Word{\\k41}less{\\k24}ly {\\k87\\-foo}watch{\\k33}ing {\\k63}he {\\k66\\-bar}waits{\\k25} {\\k44}by {\\k22\\-baz}the {\\k57}win{\\k69}dow</code>, and how the fields are populated:</p> <code>syl.text_stripped</code> Word less ly watch ing he waits by the win dow <code>syl.inline_fx</code> \"\" \"\" \"\" \"foo\" \"foo\" \"foo\" \"bar\" \"bar\" \"bar\" \"baz\" \"baz\" \"baz\" <code>syl.syl_fx</code> \"\" \"\" \"\" \"foo\" \"\" \"\" \"bar\" \"\" \"\" \"baz\" \"\" \"\" <p>TODO</p>"},{"location":"karaokes/templater-0x/#inline-variables","title":"Inline Variables","text":"<p>In a template's text, a dollar sign followed by certain names will be expanded to certain values, like <code>$loop_foo</code> as used in an earlier example. I don't support all the same loop variables as other templaters, and the ones I do support will often have different names. More loop variables will probably be added in the future, since they're so convenient. For now, see the <code>eval_inline_var</code> function for what I currently offer.</p> <p>TODO</p>"},{"location":"karaokes/templater-0x/#available-functions","title":"Available Functions","text":"<p>If present, the <code>ln.kara</code> and <code>0x.color</code> modules will be loaded automatically and can be accessed as <code>ln</code> and <code>colorlib</code>, respectively.</p> <p>Modules (code files that contain helper functions, as opposed to macros, which generally call <code>aegisub.register_macro</code> at some point) go in the <code>include</code> directory. In accordance with the standard Lua module system, those two modules must be located at <code>ln/kara.lua</code> and <code>0x/color.lua</code> respectively in order for those paths to resolve. This is completely normal; I'm not doing anything special here. Any auto4 code that loads any module follows these same rules.</p> <p>Several familiar functions from other templaters, such as <code>retime</code> and <code>maxloop</code>, are available with a few enhancements, and I also offer a few new functions.</p> <p>See the <code>util</code> and <code>template_env</code> declarations in my source code for my implementations of these functions, and to see what standard library functionality I expose by default.</p>"},{"location":"karaokes/templater-0x/#print","title":"<code>print(...)</code>","text":"<p>A handy debugging function. Works like Lua's standard <code>print</code> function, but backed by <code>aegisub.log</code>. I also offer <code>printf</code>, which is literally just an alias for <code>aegisub.log</code>.</p>"},{"location":"karaokes/templater-0x/#retimemode-start_offset0-end_offset0","title":"<code>retime(mode, start_offset=0, end_offset=0)</code>","text":"<p>If you have any past templating experience, this function should be familiar. It's the most convenient way to change an output line's start/end times.</p> <p>I have a handful of modes that can be pretty useful and aren't necessarily available in other templaters. In particular, the <code>clamp</code> modes can be used to ensure other retimes don't extend the output's start/end times past the input's.</p> Mode <code>line.start_time = start_offset +</code> <code>line.end_time = end_offset +</code> <code>\"syl\"</code> <code>orgline.start_time + syl.start_time</code> <code>orgline.start_time + syl.end_time</code> <code>\"presyl\"</code> <code>orgline.start_time + syl.start_time</code> <code>orgline.start_time + syl.start_time</code> <code>\"postsyl\"</code> <code>orgline.start_time + syl.end_time</code> <code>orgline.start_time + syl.end_time</code> <code>\"line\"</code> <code>orgline.start_time</code> <code>orgline.end_time</code> <code>\"preline\"</code> <code>orgline.start_time</code> <code>orgline.start_time</code> <code>\"postline\"</code> <code>orgline.end_time</code> <code>orgline.end_time</code> <code>\"start2syl\"</code> <code>orgline.start_time</code> <code>orgline.start_time + syl.start_time</code> <code>\"syl2end\"</code> <code>orgline.start_time + syl.end_time</code> <code>orgline.end_time</code> <code>\"presyl2postline\"</code> <code>orgline.start_time + syl.start_time</code> <code>orgline.end_time</code> <code>\"preline2postsyl\"</code> <code>orgline.start_time</code> <code>orgline.start_time + syl.end_time</code> <code>\"delta\"</code> <code>line.start_time</code> <code>line.end_time</code> <code>\"set\"</code>, <code>\"abs\"</code> <code>0</code> <code>0</code> <p>As a special case, <code>clamp</code> keeps the start and end times unchanged, unless they would fall outside the input line's start/end times (plus offsets, if applicable). Similarly, <code>clampsyl</code> does the same, but with the original syl's start/end times.</p> Mode <code>line.start_time = max(line.start_time,</code> <code>line.end_time = min(line.end_time,</code> <code>\"clamp\"</code> <code>orgline.start_time + start_offset)</code> <code>orgline.end_time + end_offset)</code> <code>\"clampsyl\"</code> <code>syl.start_time + start_offset)</code> <code>syl.end_time + end_offset)</code>"},{"location":"karaokes/templater-0x/#relayernew_layer","title":"<code>relayer(new_layer)</code>","text":"<p><code>line.layer = new_layer</code>. Enough said.</p>"},{"location":"karaokes/templater-0x/#maxloopvar-val-maxmloopvar-val","title":"<code>maxloop(var, val)</code>, <code>maxmloop(var, val)</code>","text":"<p>Basically <code>loopctx.max[var] = val</code>. Usually useful if your loop count isn't hardcoded; perhaps it's based on the width of the syllable. Note that this function will get called repeatedly if it's in a component that gets called repeatedly, so it's generally advisable to use a <code>val</code> that remains consistent across repeated calls. <code>maxloop</code> is for <code>template</code> loops, while <code>maxmloop</code> is for <code>mixin</code> loops.</p>"},{"location":"karaokes/templater-0x/#setkey-val","title":"<code>set(key, val)</code>","text":"<p><code>tenv[key] = val</code>. For if you want to assign to a (global) variable in an inline expression, and that's about it.</p>"},{"location":"karaokes/templater-0x/#skip","title":"<code>skip()</code>","text":"<p>If this function is called while generating a line, that specific line of output will be discarded. (The rest of the template will still be evaluated, resulting in a complete generated line - the only difference is that the line won't be inserted into the document.)</p> <p>One possible use case for this is to call it in a mixin that has condition modifiers of some sort to express \"If these conditions are met, do not generate output\", since condition modifiers themselves can only express \"execute only if these conditions are met\".</p> <p>This is similar to calling <code>maxloop(0)</code> in karaOK, except not tied to a somewhat orthogonal feature, so one could in theory skip certain iterations of a loop without prematurely ending the entire loop.</p>"},{"location":"karaokes/templater-0x/#unskip","title":"<code>unskip()</code>","text":"<p>Cancels the effect of a previous <code>skip()</code> call, meaning the line will once again be included in the document.</p> <p>Whichever of the two functions was called most recently takes precedence.</p>"},{"location":"karaokes/templater-0x/#mskip","title":"<code>mskip()</code>","text":"<p>Skips the current iteration of the current mixin. Works very similarly to <code>skip()</code>, but on the level of an individual mixin's evaluation.</p>"},{"location":"karaokes/templater-0x/#unmskip","title":"<code>unmskip()</code>","text":"<p>Take a wild guess.</p>"},{"location":"karaokes/templater-0x/#utiltag_or_defaulttag-default","title":"<code>util.tag_or_default(tag, default)</code>","text":"<p>logarithm's <code>ln.line.tag</code> is a nice function, but because of how other templaters treat inline expressions that evaluate to <code>nil</code>, it returns an empty string if it finds no tags. The empty string is truthy in Lua, so this means that <code>ln.line.tag(\"foo\") or \"\\\\foo(bar)\"</code> doesn't work the way one might hope. This function arose from a frustration with having to write code to do that so many times, so I allow you to just do <code>util.tag_or_default(\"foo\", \"\\\\foo(bar)\")</code>. Hooray!</p>"},{"location":"karaokes/templater-0x/#utilfadt_in-t_out","title":"<code>util.fad(t_in, t_out)</code>","text":"<p>A specialization of <code>util.tag_or_default</code>, this function will handle formatting the <code>\\fad</code> tag for you.</p>"},{"location":"karaokes/templater-0x/#utilxfobjchar-objsorglinechars-fieldcenter","title":"<code>util.xf(obj=char, objs=orgline.chars, field='center')</code>","text":"<p>Most commonly called with no arguments. Returns the position of the current character, returning 0.0 for the first char in the line and 1.0 for the final char.</p> <p>Supports the passing of alternative objects and position fields, e.g., <code>util.xf(syl, orgline.syls, 'right')</code></p> <p>In the beginning, there was <code>char.ci / #orgline.chars</code>, used by many a gradient-by-character script. However, index-based calculations are flawed for variable-width fonts, and may produce lopsided gradients depending on the glyphs within the line. Then there was <code>char.x / orgline.width</code>. This was better, but whether looking at the left, center, or right, this approach does not reach both extremes. Finally, there came <code>char.center / (final_char.center - first_char.center)</code>, and it was good. It became an annoying piece of boilerplate, though, so now I offer this function to just do it.</p> <p>This function was formerly known as <code>util.cx</code>. This name now exists as an alias for backwards compatibility.</p>"},{"location":"karaokes/templater-0x/#utillerpt-v0-v1","title":"<code>util.lerp(t, v0, v1)</code>","text":"<p>Straightforward linear interpolation of two numbers: <code>(v1 * t) + (v0 * (1 - t))</code>.</p>"},{"location":"karaokes/templater-0x/#utilgbcc1-c2-interp-tutilxf","title":"<code>util.gbc(c1, c2, interp, t=util.xf())</code>","text":"<p>A somewhat flexible function for gradient-by-character effects. Typical usage would go in a <code>mixin char</code> component and look something like <code>{\\3c!util.gbc('&amp;H0000FF&amp;', '&amp;HFF0000&amp;')!}</code>. If no <code>interp</code> function is provided, I will try to guess how to interpolate the two values. At the moment, this means: * If both values are numbers, use <code>util.lerp</code>. * If both values are strings and the first value matches the usual format for an alpha tag (i.e., the pattern <code>&amp;H[0-9a-fA-F][0-9a-fA-F]&amp;</code>), use <code>colorlib.interp_alpha</code>. * Otherwise, if they're both strings, assume they're colors and use <code>colorlib.interp_lch</code>. * Otherwise, give up.</p> <p>If this is unsatisfactory, well, that's why I expose this function's third argument: specify your own interpolation function with a signature analagous to <code>util.lerp</code>'s.</p>"},{"location":"karaokes/templater-0x/#utilmulti_gbccs-interp-tutilxf","title":"<code>util.multi_gbc(cs, interp, t=util.xf())</code>","text":"<p>Like <code>util.gbc</code>, but accepts a list of colors, for multi-stop gradients. Nifty.</p>"},{"location":"karaokes/templater-0x/#utilmake_gradv1-v2-dv1-verticaltrue-loopnamegrad-extendtrue","title":"<code>util.make_grad(v1, v2, dv=1, vertical=true, loopname='grad', extend=true)</code>","text":"<p>The first step to creating a clip-based gradient.</p> <p><code>v1</code> and <code>v2</code> are the min/max values for the span of the gradient. <code>dv</code> is the \"step size\": each segment of the gradient will generally be this size. <code>vertical</code> determines whether the gradient goes from top to bottom or from left to right. Unless <code>extend</code> is false, the first and last gradient segments will have their clips extended to the edge of the screen.</p> <p>This function calls <code>maxloop</code> in order to emit multiple lines; <code>loopname</code> can be used to specify an alternate name to use.</p>"},{"location":"karaokes/templater-0x/#utilget_gradc1-c2-interp-loopnamegrad-offset0","title":"<code>util.get_grad(c1, c2, interp, loopname='grad', offset=0)</code>","text":"<p>The second step to creating a clip-based gradient. This works in largely the same way as <code>util.gbc</code>, except that it determines the interpolation <code>t</code> value using the template loop status.</p> <p><code>offset</code> will be added to the loop state value when calculating <code>t</code>. This is useful for accurately determining the \"next\" or \"previous\" gradient value.</p>"},{"location":"karaokes/templater-0x/#utilget_multi_gradcs-interp-loopnamegrad","title":"<code>util.get_multi_grad(cs, interp, loopname='grad')</code>","text":"<p>Like <code>multi_gbc</code>, but for <code>get_grad</code>.</p>"},{"location":"karaokes/templater-0x/#utilftoan-digits2","title":"<code>util.ftoa(n, digits=2)</code>","text":"<p>Formats <code>n</code> as a string with at most <code>digits</code> decimal digits, without any unwanted trailing zeroes/decimal point. Why does no programming language ever seem to make this easy?</p>"},{"location":"karaokes/templater-0x/#utilfbfmodeline-start_offset0-end_offset0-frames1-loopnamefbf","title":"<code>util.fbf(mode='line', start_offset=0, end_offset=0, frames=1, loopname='fbf')</code>","text":"<p>Similar to <code>retime</code> in usage, but splits a line into one copy timed to each frame of video. If <code>frames</code> is set to a larger integer, then the line will be split into sections that each last that many frames. Much like <code>util.make_grad</code>, this function uses regular user-accessible template loops; the loop variable can be customized using the <code>loopname</code> argument.</p>"},{"location":"karaokes/templater-0x/#utilrandsign","title":"<code>util.rand.sign()</code>","text":"<p>Either -1 or 1, randomly.</p>"},{"location":"karaokes/templater-0x/#utilranditemlist","title":"<code>util.rand.item(list)</code>","text":"<p>A random element in the provided list. Assumes a standard 1-indexed Lua list with no gaps, like any other \"list\"-y function.</p> <p>If passed a string, returns a random UTF-8 code point from its text.</p>"},{"location":"karaokes/templater-0x/#utilrandboolp05","title":"<code>util.rand.bool(p=0.5)</code>","text":"<p>A random Boolean value, where <code>p</code> is the probability that the value is <code>true</code>.</p>"},{"location":"karaokes/templater-0x/#utilrandchoicea-b-p","title":"<code>util.rand.choice(a, b, p)</code>","text":"<p><code>if util.rand.bool(p) then a else b</code></p>"},{"location":"karaokes/templater-0x/#utilmathroundn","title":"<code>util.math.round(n)</code>","text":"<p>Rounds <code>n</code> to the nearest integer.</p>"},{"location":"karaokes/templaters-fx/","title":"Creadores de templates de karaoke","text":"<p>Haz clic aqu\u00ed para ir a la parte importante.</p> <p>Esta no es una gu\u00eda completa sobre c\u00f3mo hacer KFX, sino m\u00e1s bien una explicaci\u00f3n r\u00e1pida de las ideas principales que deber\u00edan ayudarte lo suficiente para comenzar a leer la documentaci\u00f3n de tu creador de templates favorito. Principalmente contiene una versi\u00f3n mejorada de una larga explicaci\u00f3n que escrib\u00ed en Discord en alg\u00fan momento, as\u00ed como algunas tablas que explican c\u00f3mo convertir entre los tres creadores de templates establecidos. B\u00e1sicamente, es la gu\u00eda que hubiera deseado tener al aprender esto.</p> <p>Si est\u00e1s buscando gu\u00edas reales sobre KFX, aqu\u00ed tienes algunos enlaces:</p> <ul> <li>Gu\u00eda KFX de Zahuczky: Todav\u00eda en proceso de elaboraci\u00f3n al momento que escribo esto.</li> <li>Publicaciones de Jocko: Tambi\u00e9n muy concisas y basadas en ejemplos, pero usa el creador de templates est\u00e1ndar.</li> <li>La documentaci\u00f3n real de los diversos creadores de templates, enlazada abajo.</li> </ul> <p>Adem\u00e1s, tengo aqu\u00ed una colecci\u00f3n de templates diversas que hice para la edici\u00f3n de carteles u otros fines que no son estilizaci\u00f3n de canciones.</p>"},{"location":"karaokes/templaters-fx/#creadores-de-templates-existentes","title":"Creadores de Templates Existentes","text":"<p>Al momento de escribir esto (2022), hay tres principales creadores de templates de karaoke:</p> <ol> <li>El creador de templates est\u00e1ndar que viene con Aegisub, documentado aqu\u00ed como parte de la documentaci\u00f3n de Aegisub. La documentaci\u00f3n es muy detallada, pero bastante t\u00e9cnica.</li> <li>KaraOK, una versi\u00f3n modificada del creador de templates est\u00e1ndar junto con una biblioteca de utilidades. Tambi\u00e9n se incluye por defecto con algunas versiones m\u00e1s nuevas de Aegisub, como AegisubDC.</li> <li>El Creador de Templates de The0x539, documentado aqu\u00ed en su repositorio. Este es un creador de templates completamente reescrito con una l\u00f3gica de ejecuci\u00f3n m\u00e1s potente (mixins, condicionales m\u00e1s fuertes, bucles anidados, etc) y variables organizadas de manera m\u00e1s sensata.</li> </ol> <p>Excepto por furigana y otros usos de <code>furi</code> o templates <code>multi</code>, realmente no hay nada que el creador de templates est\u00e1ndar o KaraOK puedan hacer que no pueda ser f\u00e1cilmente portado al creador de templates de The0x. Siempre que est\u00e9 instalado, el creador de templates de The0x tambi\u00e9n contiene soporte directo para la biblioteca de utilidades de KaraOK. Es por eso que ser\u00e1 el creador de templates predeterminado para esta gu\u00eda, junto con notas sobre c\u00f3mo los conceptos equivalentes funcionan en otros creadores de templates. Incluso si nunca escribir\u00e1s templates en otros creadores de templates, estos \u00faltimos a\u00fan pueden ser \u00fatiles para entender las templates existentes.</p>"},{"location":"karaokes/templaters-fx/#ver-tambien","title":"Ver tambi\u00e9n","text":"<p>Existen otras herramientas destacadas para hacer KFX. No se explican aqu\u00ed porque funcionan de manera muy diferente, pero a\u00fan as\u00ed vale la pena mencionarlas.</p> <ul> <li>KaraEffector, una gran colecci\u00f3n de plantillas existentes y formas de modificarlas.</li> <li>PyonFX, una biblioteca de Python para generar subt\u00edtulos <code>.ass</code>, adaptada para KFX.</li> <li>aegsc, un compilador que produce scripts <code>.ass</code> (especialmente templates de karaoke) que permite escribir templates con un formato m\u00e1s conveniente.</li> </ul>"},{"location":"karaokes/templaters-fx/#empezando","title":"Empezando","text":"<p>Esta gu\u00eda utiliza el Creador de Templates de The0x539, el cual necesitar\u00e1s instalar primero (tambi\u00e9n te recomiendo encarecidamente que asignes su funci\u00f3n a un atajo de teclado. Yo uso Ctrl+Alt+S). La gu\u00eda intercala explicaciones semit\u00e9cnicas (formateadas normalmente) con ejemplos muy simples pero concretos (formateados en cursiva). Tambi\u00e9n puedes seguir solo los ejemplos en cursiva si prefieres un enfoque puramente pr\u00e1ctico.</p>"},{"location":"karaokes/templaters-fx/#primeros-pasos","title":"Primeros Pasos","text":"<p>Lo siguiente es el archivo de karaoke m\u00e1s simple que puedas imaginar:</p> <pre><code>[Script Info]\nScriptType: v4.00+\nWrapStyle: 0\nScaledBorderAndShadow: yes\nYCbCr Matrix: TV.709\nPlayResX: 1920\nPlayResY: 1080\n\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\nStyle: Karaoke,Georgia,72,&amp;H002A0A00,&amp;H000019FF,&amp;H00FFFFFF,&amp;H00000000,0,0,0,0,100,100,0,0,1,2.5,0,8,30,30,25,1\n\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\nComment: 0,0:00:00.00,0:00:00.00,Karaoke,,0,0,0,template line,\nComment: 0,0:00:00.00,0:00:00.00,Karaoke,,0,0,0,,\nComment: 0,0:00:20.88,0:00:26.80,Karaoke,,0,0,0,kara,{\\k0}{\\k39}A{\\k22}to {\\k54}i{\\k44}chi{\\k40}do {\\k18}da{\\k60}ke {\\k12}ki{\\k23}se{\\k63}ki {\\k39}wa {\\k20}o{\\k20}ko{\\k39}ru {\\k36}da{\\k63}rou\nComment: 0,0:00:26.80,0:00:32.96,Karaoke,,0,0,0,kara,{\\k36}{\\k20}Ya{\\k30}sa{\\k70}shi{\\k38}i {\\k39}ko{\\k21}e {\\k58}de {\\k21}e{\\k18}ga{\\k57}ku {\\k23}yu{\\k37}gan{\\k20}da {\\k41}mi{\\k35}ra{\\k52}i\n</code></pre> <p>(Est\u00e1 sincronizado con este OP, por si deseas probarlo.)</p> <p>Contiene:</p> <ul> <li>Un estilo.</li> <li>Algunas l\u00edneas k-timeadas comentadas que tienen este estilo, marcadas con <code>kara</code> en su campo de Efecto.</li> <li>Una \u00fanica l\u00ednea (en blanco, por ahora) comentada que tiene este estilo, marcada con <code>template line</code> en el campo Efecto.</li> </ul> <p>Al ejecutar la macro <code>The0x539's Templater</code>, el creador de templates ver\u00e1 la <code>template line</code>. Para cada l\u00ednea marcada como <code>kara</code> con el mismo estilo que esta l\u00ednea, generar\u00e1 una l\u00ednea con el texto de la l\u00ednea kara, sin las etiquetas de tiempo k. Estas l\u00edneas generadas ser\u00e1n marcadas como <code>fx</code> para que puedan ser eliminadas o reemplazadas m\u00e1s tarde.</p> <p>Ten en cuenta que diferentes creadores de templates utilizan palabras clave ligeramente diferentes para algunos de estos marcadores:</p> Concepto En el Templater com\u00fan En KaraOK En The0x's Templater Marcador de l\u00ednea de karaoke <code>karaoke</code> <code>karaoke</code> <code>kara</code> or <code>karaoke</code> Template que aplica tags una vez a cada l\u00ednea <code>template pre-line</code> <code>template line</code> <code>template line</code> <p>Este es el principio de una lista m\u00e1s larga de diferencias entre los templaters. Las tablas al final de esta gu\u00eda muestran la lista completa de diferencias.</p> <p>A continuaci\u00f3n, intenta escribir <code>{\\fad(150,150)}</code> en el texto de la l\u00ednea <code>template line</code>, y aplica el template. Esto dar\u00e1 a cada l\u00ednea generada <code>fx</code> estos tags de desvanecimiento. As\u00ed que ya hemos creado una versi\u00f3n peor de HYDRA usando templates de karaoke.</p> <p>Lo que ocurre aqu\u00ed es que antes de convertir una l\u00ednea <code>kara</code> en una l\u00ednea <code>fx</code> usando una <code>template line</code>, el creador de templates a\u00f1adir\u00e1 lo que la l\u00ednea <code>template line</code> contenga delante del texto (eliminado) de la l\u00ednea <code>kara</code>. Ahora, la parte interesante es que esto no s\u00f3lo puede contener texto est\u00e1tico, sino tambi\u00e9n expresiones Lua. \u00c9stas van envueltas en signos de exclamaci\u00f3n.</p> <p>Por ejemplo, si cambias el texto de la l\u00ednea de la template por <code>{\\fad(!2*50!, 150)}</code>, obtendr\u00e1s un mont\u00f3n de l\u00edneas con tags <code>\\fad(100,150)</code>, porque lo que hab\u00eda en los signos de exclamaci\u00f3n se evalu\u00f3 a 100 usando Lua.</p> <p>Adem\u00e1s, en este entorno Lua, el creador de templates te da acceso a toda la informaci\u00f3n necesaria sobre tu l\u00ednea <code>kara</code>. Esto se almacena en la tabla <code>orgline</code>, que tiene el formato de la tabla est\u00e1ndar que describe una l\u00ednea <code>.ass</code>, pero tambi\u00e9n contiene un mont\u00f3n de campos adicionales a\u00f1adidos por karaskel o por el creador de templates de The0x. Los campos de karaskel se documentan aqu\u00ed, mientras que los campos de The0x se documentan en la documentaci\u00f3n del creador de templates.</p> <p>Por ejemplo, <code>orgline.duration</code> es la duraci\u00f3n de la l\u00ednea <code>kara</code>. As\u00ed que si pones <code>{\\t(0,!orgline.duration/2!,\\fscx150\\fscy150)\\t(!orgline.duration/2!,!orgline.duration!,\\fscx100\\fscy100)}</code> en tu <code>template line</code>, esto crear\u00eda un efecto que hace que cada l\u00ednea se haga m\u00e1s grande y m\u00e1s peque\u00f1a a lo largo de su duraci\u00f3n. Si la l\u00ednea dura 1000 ms, se convertir\u00e1 en <code>{\\t(0,500,\\fscx150\\fscy150)\\t(500,1000,\\fscx100\\fscy100)}</code>.</p> <p>Lua eval es una de las dos caracter\u00edsticas adicionales disponibles en las templates. La otra consiste en variables de l\u00ednea prefijadas por <code>$</code>, que ser\u00e1n sustituidas directamente por su valor. Esto ocurre antes de evaluar las expresiones de Lua.</p> <p>Por ejemplo, la variable de l\u00ednea <code>$ldur</code> tambi\u00e9n se eval\u00faa a la duraci\u00f3n de la l\u00ednea. As\u00ed que la plantilla anterior tambi\u00e9n podr\u00eda escribirse como <code>{\\t(0,!$ldur/2!,\\fscx150\\fscy150)\\t(!$ldur/2!,$ldur,\\fscx100\\fscy100)}</code>.  Nota que la \u00faltima aparici\u00f3n de <code>$ldur</code> no va entre signos de exclamaci\u00f3n, ya que su valor puede sustituirse directamente en el texto del comando. Sin embargo, las dos instancias anteriores todav\u00eda necesitan ocurrir dentro de un bloque Lua eval para realizar operaciones aritm\u00e9ticas con ellas despu\u00e9s.</p> <p>Las variables de l\u00ednea para el creador de templates com\u00fan est\u00e1n documentadas aqu\u00ed. KaraOK a\u00f1ade una variable de \u00edndice de caracteres <code>$ci</code>. Sin embargo, el creador de templates de The0x elimina la mayor\u00eda de estas variables de l\u00ednea. Puedes ver cu\u00e1les est\u00e1n todav\u00eda disponibles aqu\u00ed. Sin embargo, esto no es realmente una restricci\u00f3n, ya que todos sus valores (y m\u00e1s) son accesibles a trav\u00e9s de <code>orgline</code> y amigos.</p>"},{"location":"karaokes/templaters-fx/#silabas","title":"S\u00edlabas","text":"<p>Hasta ahora, solo hemos a\u00f1adido algunos tags a cada l\u00ednea k-timeada <code>kara</code>, sin usar nunca el k-timeo real. Pero ahora que hemos introducido Lua eval y variables de l\u00ednea, estamos listos para hacer efectos sensatos basados en s\u00edlabas.</p> <p>Si reemplazamos el efecto de nuestra l\u00ednea <code>template line</code> por <code>template syl</code> y aplicamos el template de nuevo, el creador de templates generar\u00e1 de repente m\u00faltiples l\u00edneas <code>fx</code> para cada l\u00ednea <code>kara</code>; una l\u00ednea <code>fx</code> por cada s\u00edlaba k-timeada de la l\u00ednea <code>kara</code>. Si no eliminaste el efecto de escalado que hicimos antes, todas estar\u00e1n apiladas unas encima de otras en la parte superior de la pantalla. Si lo eliminaste, se mover\u00e1n sucesivamente hacia abajo hasta cubrir toda la pantalla.</p> <p>Esto se debe a que, por defecto, las l\u00edneas de s\u00edlabas <code>fx</code> generadas no tienen ning\u00fan tipo de formato, por lo que naturalmente seguir\u00e1n la alineaci\u00f3n dictada por su estilo. Para posicionarlas correctamente, necesitamos usar los tags <code>\\an</code> y <code>\\pos</code> junto con algunas de las variables que nos da el creador de templates. Ya hemos usado antes <code>orgline</code>, y <code>orgline.left</code> nos da la posici\u00f3n X del borde izquierdo de la l\u00ednea <code>kara</code>, al formatearla con el estilo que tenga. Del mismo modo, <code>orgline.top</code> nos da la coordenada Y del borde superior.</p> <p>Para colocar cada s\u00edlaba donde debe ir, podemos utilizar la tabla an\u00e1loga <code>syl</code>, que (obviamente) contiene informaci\u00f3n similar sobre la s\u00edlaba. Lo m\u00e1s importante es que <code>syl.left</code> contiene la posici\u00f3n X del borde izquierdo de la s\u00edlaba, respecto a la l\u00ednea en la que est\u00e1.</p> <p>Con esto en mente, podemos escribir lo siguiente en nuestro <code>template syl</code>: <code>{\\an7\\pos(!orgline.left+syl.left!,!orgline.top!)}</code>. Si ahora volvemos a aplicar nuestro template, todas las s\u00edlabas estar\u00e1n en la posici\u00f3n correcta.</p> <p>Ahora, mientras que <code>\\an7</code> fue el ejemplo m\u00e1s f\u00e1cil, pero rara vez es conveniente para cualquier efecto real. As\u00ed que vamos a utilizar en su lugar, <code>{\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}</code> que utiliza las variables an\u00e1logas para las posiciones X e Y de la mitad de la l\u00ednea o s\u00edlaba. Esto no cambia el posicionamiento, pero utiliza <code>\\an5</code> en su lugar, que es m\u00e1s \u00fatil en casi todos los casos.</p> <p>En el creador de templates com\u00fan o KaraOK tambi\u00e9n puedes encontrar variables de l\u00ednea como <code>$scenter</code> y <code>$lmiddle</code> usadas para esto<sup>1</sup>. No necesitamos <code>syl</code> para la posici\u00f3n Y, ya que la posici\u00f3n Y de la s\u00edlaba no depende de la l\u00ednea con formato normal. De hecho, <code>syl.middle</code> ni siquiera existe.</p> <p>Con todo lo que sabemos ahora, ya podemos hacer un simple template. Las \u00fanicas piezas que nos faltan son las variables <code>syl.duration</code>, <code>syl.start_time</code> y <code>syl.end_time</code>, que son la duraci\u00f3n de la s\u00edlaba y los tiempos de inicio y fin en milisegundos respectivamente, siendo estos dos \u00faltimos relativos al tiempo de inicio de la l\u00ednea actual. Con esto, podemos hacer un simple template...</p> <pre><code>{\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)\n\\t(!syl.start_time!,!syl.start_time+syl.duration/2!,\\fscx130\\fscy130)\n\\t(!syl.start_time+syl.duration/2!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>... que resalta cada s\u00edlaba haci\u00e9ndola m\u00e1s grande y m\u00e1s peque\u00f1a de nuevo.</p> <p>Nota: Esto es solo un ejemplo de estilo, dise\u00f1ado para ser lo m\u00e1s simple posible. No es un estilo perfecto, ni es un estilo que debas copiar en absoluto. Su mayor problema es que el escalado de las s\u00edlabas resaltadas sigue una simple curva triangular: crece durante la mitad de la duraci\u00f3n de la s\u00edlaba y se reduce durante la otra mitad. Esto har\u00e1 que las s\u00edlabas cortas crezcan y se reduzcan muy r\u00e1pidamente, mientras que las s\u00edlabas m\u00e1s largas crecen y se reducen muy lentamente, alcanzando su tama\u00f1o m\u00e1ximo demasiado tarde. Para el estilo real de la canci\u00f3n, deber\u00eda hacer que el realce siguiera algo parecido a una curva ADSR, es decir, dejar los tiempos de crecimiento y encogimiento algo constantes y mantener el efecto de realce durante alg\u00fan tiempo para las s\u00edlabas m\u00e1s largas.</p> <p>Ya expliqu\u00e9 la mayor\u00eda de los conceptos b\u00e1sicos de templates, y espero que ahora puedas leer la documentaci\u00f3n de los distintos creadores de templates o diseccionar los templates existentes (estos, por ejemplo) para profundizar. Sigue leyendo si quieres una introducci\u00f3n a algunos de los conceptos m\u00e1s espec\u00edficos.</p>"},{"location":"karaokes/templaters-fx/#efectos-multilinea-y-mixins","title":"Efectos multil\u00ednea y mixins","text":"<p>Nuestra <code>template syl</code> genera una l\u00ednea <code>fx</code> por cada s\u00edlaba de entrada. Si queremos hacer un efecto que genere m\u00faltiples l\u00edneas para cada s\u00edlaba podemos a\u00f1adir m\u00e1s l\u00edneas <code>template syl</code>. (Para efectos m\u00e1s complejos, tambi\u00e9n podemos usar bucles).</p> <p>Por ejemplo, vamos a a\u00f1adir un efecto de brillo azulado a nuestras l\u00edneas de karaoke. Toma la l\u00ednea <code>template syl</code> que hicimos antes, y dupl\u00edcala. Aumenta la capa de la segunda en uno, y a\u00f1ade <code>\\3c&amp;HFFCCCC&amp;\\bord5\\blur5</code> a la primera. Si ahora aplicas el template, se generar\u00e1n dos l\u00edneas <code>fx</code> para cada s\u00edlaba, una para cada <code>template syl</code>. Las l\u00edneas <code>fx</code> tambi\u00e9n tendr\u00e1n las mismas capas que sus respectivas l\u00edneas <code>template syl</code>.</p> <p>Pero si no tenemos cuidado (como ocurri\u00f3 en este ejemplo), esto duplica ahora gran parte del c\u00f3digo de nuestro template. Si queremos cambiar alg\u00fan elemento del efecto de resaltado, necesitar\u00edamos cambiar ambas l\u00edneas <code>template syl</code>. Aqu\u00ed es donde los mixins son muy \u00fatiles.</p> <p>Los mixins son una forma de aplicar tags adicionales (o cualquier texto, en realidad) a alg\u00fan subconjunto de las l\u00edneas <code>fx</code> generadas. Por ejemplo, por defecto una l\u00ednea <code>mixin syl</code> a\u00f1adir\u00e1 su contenido a cada s\u00edlaba de cada l\u00ednea generada, sin importar si es de una <code>template line</code> o de una <code>template syl</code>. Usando modificadores como <code>layer</code>, <code>t_actor</code>, o <code>if</code> y <code>unless</code>, podemos restringir a qu\u00e9 l\u00edneas se aplica un mixin. Esto es muy \u00fatil tanto para limpiar templates y eliminar c\u00f3digo duplicado, como para el formateo condicional.</p> <p>En nuestro caso, podemos reescribir nuestro template de la siguiente manera:</p> <pre><code>[layer 0] template syl: {\\3c&amp;HFFCCCC&amp;\\bord5\\blur5}\n[layer 1] template syl:\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)\n                         \\t(!syl.start_time!,!syl.start_time+syl.duration/2!,\\fscx130\\fscy130)\n                         \\t(!syl.start_time+syl.duration/2!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>De hecho, al dividir el <code>mixin</code> en m\u00faltiples partes, podemos separar las diferentes partes de este template por su prop\u00f3sito, y hacerlo m\u00e1s f\u00e1cil de leer:</p> <pre><code>[layer 0] template syl: {\\3c&amp;HFFCCCC&amp;\\bord5\\blur5}\n[layer 1] template syl:\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}\n             mixin syl: {\\t(!syl.start_time!,!syl.start_time+syl.duration/2!,\\fscx130\\fscy130)\n                         \\t(!syl.start_time+syl.duration/2!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>Los mixins (al menos en esta capacidad) son una caracter\u00edstica exclusiva del creador de templates de The0x. Lea su documentaci\u00f3n para encontrar todos los modificadores posibles para la ejecuci\u00f3n condicional.</p>"},{"location":"karaokes/templaters-fx/#lineas-de-codigo","title":"L\u00edneas de c\u00f3digo","text":"<p>Ahora que tenemos toda la funcionalidad b\u00e1sica, podemos hablar de l\u00edneas de c\u00f3digo. Estas te permiten escribir c\u00f3digo Lua que se ejecuta una vez, o una vez por cada l\u00ednea, s\u00edlaba, palabra o car\u00e1cter. Los usos simples incluyen la definici\u00f3n de constantes o funciones que calculan valores que necesitas en tus templates. Son bastante autoexplicativos, y todo lo dem\u00e1s importante se explica en la documentaci\u00f3n, as\u00ed que aqu\u00ed solo hay un ejemplo de uso r\u00e1pido para completar nuestra plantilla de ejemplo:</p> <p>En este momento, nuestro template hace que las s\u00edlabas se agranden en la primera mitad de su duraci\u00f3n, y se achiquen en la segunda mitad. Si queremos que crezcan m\u00e1s r\u00e1pido, podemos usar algo como <code>syl.start_time + 0.3 * syl.duration</code> en los tags <code>\\t</code>. Pero ahora, tenemos que escribir el <code>0.3</code> dos veces. Si queremos cambiar el valor m\u00e1s tarde, podr\u00edamos olvidar uno de los dos y romper el efecto. As\u00ed que pongamos esto en una variable constante:</p> <pre><code>             code once: ticreci = 0.3\n[layer 0] template syl: {\\3c&amp;HFFCCCC&amp;\\bord5\\blur5}\n[layer 1] template syl:\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}\n             mixin syl: {\\t(!syl.start_time!,!syl.start_time+ticreci*syl.duration!,\\fscx130\\fscy130)\n                         \\t(!syl.start_time+ticreci*syl.duration!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>Ya que estamos en ello, demos tambi\u00e9n nombres a algunas de las otras constantes:</p> <pre><code>             code once: ticreci = 0.3; escalacreci = 130; colorbrillo = \"&amp;HFFCCCC\";\n[layer 0] template syl: {\\3c!colorbrillo!\\bord5\\blur5}\n[layer 1] template syl:\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}\n             mixin syl: {\\t(!syl.start_time!,!syl.start_time+ticreci*syl.duration!,\\fscx!escalacreci!\\fscy!escalacreci!)\n                         \\t(!syl.start_time+ticreci*syl.duration!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>Tambi\u00e9n podr\u00edamos tener una l\u00ednea <code>code once</code> separada para cada constante, eso es solo cuesti\u00f3n de gustos.</p> <p>Para no tener que teclear <code>!syl.start_time+ticreci*syl.duration!</code> dos veces, tambi\u00e9n podr\u00edamos convertir esto en una variable. Podemos hacerlo con un <code>code syl</code>, o con la funci\u00f3n <code>set</code>:</p> <pre><code>             code once: ticreci = 0.3; escalacreci = 130; colorbrillo = \"&amp;HFFCCCC\";\n[layer 0] template syl: {\\3c!colorbrillo!\\bord5\\blur5}\n[layer 1] template syl:\n             code  syl: ticre = syl.start_time+ticreci*syl.duration\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}\n             mixin syl: {\\t(!syl.start_time!,!ticre!,\\fscx!escalacreci!\\fscy!escalacreci!)\n                         \\t(!ticre!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>o</p> <pre><code>             code once: ticreci = 0.3; escalacreci = 130; colorbrillo = \"&amp;HFFCCCC\";\n[layer 0] template syl: {\\3c!colorbrillo!\\bord5\\blur5}\n[layer 1] template syl:\n             mixin syl: {\\an5\\pos(!orgline.left+syl.center!,!orgline.middle!)}\n             mixin syl: {!set(\"ticre\", syl.start_time+ticreci*syl.duration)!\n                         \\t(!syl.start_time!,!ticre!,\\fscx!escalacreci!\\fscy!escalacreci!)\n                         \\t(!ticre!,!syl.end_time!,\\fscx100\\fscy100)}\n</code></pre> <p>La segunda es probablemente m\u00e1s f\u00e1cil de leer, pero la primera puede ser m\u00e1s limpia si necesitas esta variable en m\u00faltiples templates o mixins.</p>"},{"location":"karaokes/templaters-fx/#funciones","title":"Funciones","text":"<p>Los creadores de templates proporcionan varias funciones \u00fatiles para modificar a\u00fan m\u00e1s la l\u00ednea actual. Todas est\u00e1n documentadas en la documentaci\u00f3n del respectivo creador de templates. Solo quiero destacar la m\u00e1s importante, llamada <code>retime</code>.</p> <p>La funci\u00f3n <code>retime</code> te permite cambiar el tiempo de salida de la l\u00ednea. No hay ninguna magia involucrada aqu\u00ed; la tabla <code>line</code> siempre contiene los campos de la l\u00ednea que se est\u00e1 generando actualmente y puede ser cambiada por cualquiera, as\u00ed que nadie te impide escribir <code>!(function() line.start_time = 1234 end)()!</code> para establecer el tiempo de inicio de la l\u00ednea <code>fx</code> generada a <code>1:23</code>. La funci\u00f3n <code>retime</code> hace esto mucho m\u00e1s c\u00f3modo.</p> <p>Por ejemplo, incluso con <code>template syl</code>, la l\u00ednea generada utiliza por defecto el tiempo de la l\u00ednea original <code>kara</code>. Si en cambio quieres que solo aparezca cuando la s\u00edlaba est\u00e1 siendo resaltada, puedes a\u00f1adir <code>!retime(\"syl\")!</code> a tu template para establecer su tiempo de inicio y fin al tiempo (absoluto) de inicio y fin de la s\u00edlaba, respectivamente. Si quieres un lead-in y lead-out de 150 y 300 milisegundos respectivamente, puedes escribir <code>!retime(\"syl\", -150, 300)!</code>. Si por el contrario quieres que la s\u00edlaba desaparezca justo cuando deber\u00eda empezar a resaltarse, puedes usar <code>!retime(\"start2syl\")!</code> en su lugar. Consulta la documentaci\u00f3n para conocer todos los modos posibles.</p>"},{"location":"karaokes/templaters-fx/#bucles","title":"Bucles","text":"<p>Por \u00faltimo, hablemos de los bucles. Puedes usar bucles en templates para crear efectos m\u00e1s complejos, como generar m\u00faltiples l\u00edneas a partir de cada aplicaci\u00f3n de cualquier l\u00ednea de <code>template</code>. Tambi\u00e9n puedes establecer el n\u00famero de iteraciones durante el tiempo de ejecuci\u00f3n. Con el creador de templates de The0x, puedes incluso utilizar m\u00faltiples bucles anidados. Usando la funci\u00f3n <code>util.fbf</code>, tambi\u00e9n puedes configurar f\u00e1cilmente un bucle que genere una l\u00ednea de salida para cada fotograma. Los mixins tambi\u00e9n soportan bucles en el creador de templates de The0x.</p> <p>Por ejemplo, considera una l\u00ednea con el efecto <code>template line loop myloop 5</code> y el texto...</p> <pre><code>{!relayer($maxloop_myloop - $loop_myloop)!\n\\an5\\pos(!line.center - $loop_myloop - 1!,!line.middle + $loop_myloop - 1!)}\n</code></pre> <p>... para hacer algo como una sombra s\u00f3lida. O podr\u00edas tener una simple <code>template line</code> con el texto...</p> <pre><code>{!util.fbf(\"line\")!\\an5\n\\pos(!line.center + 100 * math.sin(2 * (line.start_time - orgline.start_time) / 1000)!, !line.middle!)}\n</code></pre> <p>... para hacer que la l\u00ednea se mueva suavemente de lado a lado.</p> <p>Para los efectos frame a frame que no utilizan posicionamiento, tambi\u00e9n podr\u00edan interesarte las funciones de onda de KaraOK, que tambi\u00e9n est\u00e1n disponibles en el creador de templates de The0x.</p>"},{"location":"karaokes/templaters-fx/#otros","title":"Otros","text":"<p>Algunas cosas que no he mencionado aqu\u00ed son: - Actores: Hacer que los efectos se comporten de manera diferente (digamos, que tengan diferentes colores) dependiendo de los campos Actor de las l\u00edneas <code>kara</code>. - Efectos en l\u00ednea(Inline FX): Usar marcadores en las l\u00edneas <code>kara</code> para tener diferentes efectos para s\u00edlabas individuales. - Las otras poderosas caracter\u00edsticas de ejecuci\u00f3n condicional de los mixins, particularmente <code>if</code> y <code>unless</code>. - Gradientes usando la librer\u00eda de utilidades del creador de templates de The0x, as\u00ed como la librer\u00eda color. - Estilo Furigana.</p> <p>De nuevo, lee la documentaci\u00f3n para ver qu\u00e9 es posible all\u00ed.</p>"},{"location":"karaokes/templaters-fx/#comparacion","title":"Comparaci\u00f3n","text":"<p>Las principales diferencias entre los creadores de templates, ya sea el com\u00fan o KaraOK y el de The0x son:</p> <ul> <li>El componente <code>mixin</code> y la clase <code>word</code>.</li> <li>Falta de las clases/modificadores <code>multi</code>/<code>furi</code>.</li> <li>La mayor\u00eda de las variables de d\u00f3lar necesitan ser accedidas a trav\u00e9s de las tablas <code>tenv</code> en lua en l\u00ednea (in inline lua).</li> <li>Bucles nombrados y anidables.</li> <li>Ejecuci\u00f3n condicional (aplicable a todos los componentes, no solo a <code>mixin</code>).</li> </ul> <p>A continuaci\u00f3n se ofrece una lista m\u00e1s completa.</p> <p>Ten en cuenta que todos los enlaces a las secciones de c\u00f3digo de los distintos creadores de templates son enlaces permanentes y pueden estar obsoletos.</p>"},{"location":"karaokes/templaters-fx/#marcadores-de-linea","title":"Marcadores de l\u00ednea","text":"<p>Esta no es una lista completa. Consulta la documentaci\u00f3n para ver todos los modificadores posibles.</p> Templater com\u00fan KaraOK Templater de The0x <code>karaoke</code> <code>karaoke</code> <code>kara</code> o <code>karaoke</code> <code>fx</code> <code>fx</code> <code>fx</code> <code>template pre-line</code> <code>template line</code> <code>template line</code> <code>template syl</code> <code>template syl</code> <code>template syl</code> <code>template char</code> o <code>template syl char</code> <code>template char</code> <code>template char</code> no presente <code>template word</code> <code>template word</code> <code>template line</code> <code>template lsyl</code> <code>template line</code> + <code>mixin syl</code> <code>template furi</code> <code>template furi</code> no presente no presente <code>template furichar</code> no presente no presente <code>template lchar</code> <code>template line</code> + <code>mixin char</code> no presente <code>template lword</code> <code>template line</code> + <code>mixin word</code> <code>all</code> (para template y componentes de c\u00f3digo) <code>all</code> <code>anystyle</code> no presente <code>all style &lt;stylename&gt;</code> <code>style &lt;stylename&gt;</code> no presente no presente general <code>mixin line</code> no presente no presente general <code>mixin syl</code> no presente no presente general <code>mixin char</code> no presente no presente general <code>mixin word</code> <code>code once</code> <code>code once</code> <code>code once</code> <code>code line</code> <code>code line</code> <code>code line</code> <code>code syl</code> <code>code syl</code> <code>code syl</code> no presente <code>code char</code> <code>code char</code> no presente <code>code word</code> <code>code word</code> <code>code furi</code> <code>code furi</code> no presente <code>loop n</code> <code>loop n</code> <code>loop &lt;loopname&gt; n</code>"},{"location":"karaokes/templaters-fx/#tablas-en-tenv","title":"Tablas en tenv","text":"<ul> <li>En todos los creadores de templates, <code>orgline</code>, <code>syl</code>, <code>char</code> y <code>word</code> (donde est\u00e9n presentes y sean aplicables) se refieren a objetos originales, mientras que <code>line</code> se refiere a la l\u00ednea <code>fx</code> que ser\u00e1 generada.</li> <li>En el creador de templates com\u00fan y en KaraOK, <code>syl</code> es la s\u00edlaba actual para las l\u00edneas <code>template syl</code>, pero es el car\u00e1cter actual para las l\u00edneas <code>template char</code>. De hecho, <code>template char</code> solo se traduce a <code>template syl</code> con una marca por car\u00e1cter (per-char) internamente.</li> <li>Los creadores de templates m\u00e1s recientes a\u00f1aden tablas que describen la palabra o s\u00edlaba actual para las l\u00edneas <code>template char</code>:<ul> <li>En el creador de templates com\u00fan, <code>word</code> y <code>char</code> no existen.</li> <li>KaraOK a\u00f1ade las tablas <code>char</code>, <code>word</code> y <code>syll</code> (las dos \u00faltimas tambi\u00e9n son accesibles a trav\u00e9s de <code>char.word</code> y <code>char.syll</code> en <code>template char</code>) referenciando el car\u00e1cter, palabra y s\u00edlaba actuales en <code>template char</code>.</li> <li>En el creador de templates de The0x, sin embargo, <code>syl</code>, <code>char</code> y <code>word</code> solo existen para <code>template syl</code>, <code>template char</code> y <code>template word</code> respectivamente, y hacen referencia al objeto respectivo. Se puede acceder a la s\u00edlaba o palabra actual con <code>char.syl</code> y <code>char.word</code> respectivamente.</li> </ul> </li> </ul>"},{"location":"karaokes/templaters-fx/#otros-miembros-de-tenv","title":"Otros miembros de tenv","text":"<p>Aparte de las diferentes tablas de l\u00edneas, funciones de utilidad y variables de bucle, los creadores de templates exponen diferentes librer\u00edas y datos en <code>tenv</code>, a los que se puede acceder directamente desde los campos Lua eval:</p> <ul> <li>Los tres creadores de templates proporcionan el entorno global <code>_G</code> del template(templater) que llama a <code>tenv</code>, a trav\u00e9s del cual se puede acceder a todas las dem\u00e1s variables globales. Por ejemplo, en el creador de templates com\u00fan o en KaraOK, se puede acceder a la librer\u00eda <code>unicode</code> de Aegisub a trav\u00e9s de <code>_G.unicode</code>.</li> <li>El creador de templates com\u00fan solo expon\u00eda las librer\u00edas <code>string</code> y <code>math</code>, como se ve aqu\u00ed. El miembro final <code>meta</code> es el mapa de campos de metadatos de script en la secci\u00f3n <code>[Script Info]</code> del archivo de subt\u00edtulos, como recogido por karaskel.</li> <li>Adem\u00e1s de esto, KaraOK expone la librer\u00eda <code>math</code>, as\u00ed como el objeto de subt\u00edtulos <code>subs</code> y varias funciones de utilidad como <code>ipairs</code> y <code>tostring</code>. La lista completa est\u00e1 aqu\u00ed.</li> <li>El creador de templates de The0x expone todas las librer\u00edas que hace KaraOK, junto con las librer\u00edas de Aegisub <code>unicode</code> y <code>karaskel</code>. Cuando est\u00e1 disponible, tambi\u00e9n expone la librer\u00eda de KaraOK como <code>ln</code> (que se inicializa autom\u00e1ticamente), y la librer\u00eda color de The0x como <code>colorlib</code>. El creador de templates de The0x no expone todas las funciones de utilidad de KaraOK (<code>ipairs</code> es la m\u00e1s notable), pero expone algunas otras funciones como <code>require</code>. Ver aqu\u00ed para una lista completa. El creador de templates tambi\u00e9n expone los objetos <code>subs</code>, <code>meta</code> y <code>styles</code>, y su propia librer\u00eda de utilidades aqu\u00ed.</li> </ul>"},{"location":"karaokes/templaters-fx/#variables-de-linea","title":"Variables de l\u00ednea","text":"<ul> <li>La siguiente lista es completa con respecto a las variables de l\u00ednea en el creador de templates com\u00fan y KaraOK. Est\u00e1 en el mismo orden que la documentaci\u00f3n para variables de l\u00ednea en el creador de templates com\u00fan, as\u00ed que refi\u00e9rase a ella para las explicaciones de estas variables.<ul> <li>El creador de templates de The0x contiene variables de l\u00ednea adicionales para trabajar con bucles, as\u00ed como las variables <code>$env_*</code> (ver el c\u00f3digo fuente para estas).</li> </ul> </li> <li>Las expresiones de la siguiente tabla son an\u00e1logas entre s\u00ed, pero pueden no ser exactamente iguales. En particular, algunos valores se redondean en el creador de templates com\u00fan.</li> <li>Muchas de las expresiones listadas a continuaci\u00f3n para el creador de templates de The0x tambi\u00e9n funcionan para el creador de templates com\u00fan y KaraOK.</li> </ul> Templater com\u00fan &amp; KaraOK Templater de The0x <code>$layer</code> <code>orgline.layer</code> <code>$lstart</code> <code>orgline.start_time</code> <code>$lend</code> <code>orgline.end_time</code> <code>$ldur</code> <code>$ldur</code> o <code>orgline.duration</code> <code>$lmid</code> <code>orgline.start_time + 0.5 * orgline.duration</code> <code>$style</code> <code>orgline.style</code> <code>$actor</code> <code>orgline.actor</code> <code>$margin_l</code> <code>orgline.eff_margin_l</code> <code>$margin_r</code> <code>orgline.eff_margin_r</code> <code>$margin_t</code> <code>orgline.eff_margin_t</code> <code>$margin_b</code> <code>orgline.eff_margin_b</code> <code>$margin_v</code> <code>orgline.eff_margin_v</code> <code>$syln</code> <code>#orgline.syls</code> <code>$li</code> <code>$li</code> o <code>orgline.li</code> <code>$lleft</code> <code>orgline.left</code> <code>$lcenter</code> <code>orgline.center</code> <code>$lright</code> <code>orgline.right</code> <code>$ltop</code> <code>orgline.top</code> <code>$lmiddle</code> <code>orgline.middle</code> <code>$lbottom</code> <code>orgline.bottom</code> <code>$lx</code> no presente <code>$ly</code> no presente <code>$lwidth</code> <code>orgline.width</code> <code>$lheight</code> <code>orgline.height</code> <code>$sstart</code> <code>$sylstart</code> o <code>syl.start_time</code> <code>$send</code> <code>$sylend</code> o <code>syl.end_time</code> <code>$smid</code> <code>syl.start + 0.5 * syl.duration</code> <code>$sdur</code> <code>$syldur</code> o <code>syl.duration</code> <code>$si</code> <code>$si</code> o <code>(syl o char u orgline).si</code> <code>$ci</code> (solo KaraOK) <code>$ci</code> o <code>(char o syl o word u orgline).ci</code> no presente <code>$wi</code> o <code>(word o char u orgline).wi</code> no presente <code>$cxf</code> no presente <code>$sxf</code> no presente <code>$wxf</code> <code>$skdur</code> <code>$kdur</code> o <code>syl.kdur</code> o <code>syl.duration / 2</code> <code>$sleft</code> <code>orgline.left + syl.left</code> <code>$scenter</code> <code>orgline.left + syl.center</code> <code>$sright</code> <code>orgline.left + syl.right</code> <code>$sbottom</code> igual que <code>$lbottom</code> <code>$smiddle</code> igual que <code>$lmiddle</code> <code>$stop</code> igual que <code>$ltop</code> <code>$sx</code> no presente <code>$sy</code> no presente <code>$swidth</code> <code>syl.width</code> <code>$sheight</code> <code>syl.height</code> Automatic variants no presente <ol> <li> <p>Soy consciente de que <code>$smiddle</code> tambi\u00e9n existe, pero estoy intentando resaltar el patr\u00f3n <code>$s[var]</code> y <code>$l[var]</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"programacion/assf/","title":"Assf","text":"<p>ASSFoundation es un m\u00f3dulo que tiene como objetivo hacer que el trabajo con objetos de subt\u00edtulos sea eficiente. Realiza la mayor parte del trabajo pesado para que podamos hacer m\u00e1s con menos l\u00edneas de c\u00f3digo en nuestro script. Proporciona diversas funciones que nos permiten trabajar con l\u00edneas, etiquetas, dibujos, texto y comentarios. Esto hace innecesario reinventar la rueda y escribir tus propias funciones para la mayor\u00eda de las tareas comunes, mientras te permite realizar tareas complejas de manera m\u00e1s sencilla.</p> <p>Esta gu\u00eda asume que ya sabes c\u00f3mo escribir scripts para Aegisub y conoces los conceptos b\u00e1sicos de Moonscript.</p>"},{"location":"programacion/assf/#esqueleto-de-scripts-de-aegisub","title":"Esqueleto de Scripts de Aegisub","text":"<pre><code>export script_name = \"nombre del script\"\nexport script_description = \"descripci\u00f3n de tu script\"\nexport script_version = \"0.0.1\"\nexport script_author = \"t\u00fa\"\nexport script_namespace = \"espacio de nombres de tu script\"\n\nDependencyControl = require \"l0.DependencyControl\"\ndepctrl = DependencyControl{\n  {\n    {\"a-mo.LineCollection\", version: \"1.3.0\", url: \"https://github.com/TypesettingTools/Aegisub-Motion\",\n      feed: \"https://raw.githubusercontent.com/TypesettingTools/Aegisub-Motion/DepCtrl/DependencyControl.json\"},\n    {\"l0.ASSFoundation\", version: \"0.4.0\", url: \"https://github.com/TypesettingTools/ASSFoundation\",\n      feed: \"https://raw.githubusercontent.com/TypesettingTools/ASSFoundation/master/DependencyControl.json\"}\n  }\n}\nLineCollection, ASS = depctrl\\requireModules!\nlogger = depctrl\\getLogger!\n\nfunctionName = (sub, sel, act) -&gt;\n  -- aqu\u00ed va el contenido\n\ndepctrl\\registerMacro functionName\n</code></pre> <p>Este es el marco que tendr\u00e1n todos tus scripts. Aqu\u00ed importamos LineCollection y ASSFoundation. Tambi\u00e9n importamos Logger para fines de registro, pero si no necesitas registrar nada, puedes eliminar esa l\u00ednea. Finalmente, definimos una funci\u00f3n llamada <code>functionName</code>. Este nombre de funci\u00f3n es el que registramos en Aegisub en la \u00faltima l\u00ednea, y se ejecuta tan pronto como ejecutamos el script. Todo lo que hagamos en la gu\u00eda a continuaci\u00f3n ir\u00e1 dentro de la funci\u00f3n donde dice <code>--aqu\u00ed va el contenido</code>.</p>"},{"location":"programacion/assf/#linecollection","title":"LineCollection","text":"<p>LineCollection no es parte de ASSFoundation, pero casi todo lo que ASSFoundation hace actuar\u00e1 sobre la tabla de l\u00edneas generada por LineCollection. La tabla de l\u00edneas generada por LineCollection tendr\u00e1 todos los campos de una tabla de l\u00edneas normal, pero tambi\u00e9n agrega otros campos. Algunos de los nuevos campos que son \u00fatiles para escribir automatizaciones en Aegisub son:</p> Campos Significado Tipo duration Duraci\u00f3n de la l\u00ednea en ms entero startFrame Primer fotograma de una l\u00ednea entero endFrame \u00daltimo fotograma de una l\u00ednea entero styleRef Tabla de estilos tabla number N\u00famero de una l\u00ednea en el archivo de subt\u00edtulos entero humanizedNumber N\u00famero de una l\u00ednea como se ve en Aegisub entero <p>Algunos de los m\u00e9todos que LineCollection nos proporciona para modificar subt\u00edtulos son:</p> M\u00e9todo Uso Significado LineCollection lines = LineCollection sub, sel A\u00f1ade todas las l\u00edneas seleccionadas a una variable llamada <code>lines</code> (ignora las l\u00edneas comentadas). replaceLines lines\\replaceLines! Cualquier cambio que hagas en <code>lines</code> se volver\u00e1 a aplicar al archivo de subt\u00edtulos. deleteLines lines\\deleteLines! Elimina todas las l\u00edneas. lines\\deleteLines tbl Proporciona una tabla de l\u00edneas para eliminar solo esas l\u00edneas. insertLines lines\\insertLines! Inserta l\u00edneas en el archivo de subt\u00edtulos. newLines\\insertLines Inserta un nuevo conjunto de l\u00edneas que has definido llamado newLines. addLine lines\\addLine A\u00f1ade una l\u00ednea al archivo de subt\u00edtulos. <p>Puedes trabajar en la tabla de l\u00edneas generada por LineCollection sin usar ASSFoundation, como se muestra en el siguiente ejemplo donde cambiamos el efecto de la l\u00ednea a \"Actor\":</p> <pre><code>functionName = (sub, sel) -&gt;\n  lines = LineCollection sub, sel\n  for line in *lines\n    line.effect = \"Actor\"\n  lines\\replaceLines!\n</code></pre> <p>Sin embargo, utilizaremos LineCollection junto con ASSFoundation para aprovechar al m\u00e1ximo ambos m\u00f3dulos.</p>"},{"location":"programacion/assf/#logger","title":"Logger","text":"<p>Logger es un m\u00f3dulo de registro de DependencyControl que puedes usar para registrar mensajes. Si no especificas un nivel de registro, el nivel de registro predeterminado es 2. Por defecto, el nivel de registro de Aegisub est\u00e1 configurado en 3, lo que significa que los mensajes con un nivel superior a 3 no ser\u00e1n vistos por el usuario final a menos que ellos mismos configuren un nivel de registro m\u00e1s alto. El script se detiene despu\u00e9s de mostrar el mensaje si el nivel de registro es inferior a 2.</p> <pre><code>logger\\log \"Un mensaje simple entre comillas\"\nlogger\\log 4, \"Un mensaje simple entre comillas pero con nivel de registro 4\"\n\n-- dump es la parte m\u00e1s \u00fatil de logger en lo que respecta a la depuraci\u00f3n. \n-- Puedes pasar una tabla y mostrar\u00e1 una vista formateada con todas sus claves y valores.\nlogger\\dump table\n\n-- Con niveles de registro predefinidos:\nlogger\\fatal \"mensaje\"                                  -- nivel de registro 0\nlogger\\error \"mensaje\"                                  -- nivel de registro 1\nlogger\\warn \"mensaje\"                                   -- nivel de registro 2\nlogger\\hint \"mensaje\"                                   -- nivel de registro 3\nlogger\\debug \"mensaje\"                                  -- nivel de registro 4\nlogger\\trace \"mensaje\"                                  -- nivel de registro 5\nlogger\\assert condition, \"Mostrar este mensaje si la condici\u00f3n es false\" -- nivel de registro 1\n</code></pre>"},{"location":"programacion/assf/#nombres-de-las-etiquetas-entendidas-por-assfoundation","title":"Nombres de las etiquetas entendidas por ASSFoundation","text":"Etiqueta Nombre en ASSFoundation \\fscx scale_x \\fscy scale_y \\an align \\frz angle \\fry angle_y \\frx angle_x \\bord outline \\xbord outline_x \\ybord outline_y \\shad shadow \\xshad shadow_x \\yshad shadow_y \\r reset \\pos position \\move move \\org origin \\alpha alpha \\1a alpha1 \\2a alpha2 \\3a alpha3 \\4a alpha4 \\1c color1 \\2c color2 \\3c color3 \\4c color4 \\clip clip_vect \\iclip iclip_vect \\clip clip_rect \\iclip iclip_rect \\p drawing \\be blur_edges \\blur blur \\fax shear_x \\fay shear_y \\b bold \\i italic \\u underline \\s strikeout \\fsp spacing \\fs fontsize \\fn fontname \\k k_fill \\kf k_sweep \\ko k_bord \\q wrapstyle \\fad fade_simple \\fade fade \\t transform"},{"location":"programacion/assf/#recorrer-todas-las-lineas-usando-linecollection","title":"Recorrer todas las l\u00edneas usando LineCollection","text":"<pre><code>lines = LineCollection sub, sel\nreturn if #lines.lines == 0\nlines\\runCallback (lines, line, i) -&gt;\n  -- hacer algo con cada l\u00ednea\n</code></pre> <p>Este es el m\u00e9todo usual para recorrer todas las l\u00edneas seleccionadas. Por defecto, omite todas las l\u00edneas comentadas y recorre en orden inverso. Por lo tanto, la \u00faltima l\u00ednea seleccionada ser\u00e1 la primera en la que trabajes. Generalmente, si tu script est\u00e1 destinado a trabajar en todas las l\u00edneas seleccionadas, esto es lo que usar\u00edas.</p> <p>Si el orden es importante para ti, recorrer\u00edas las l\u00edneas seleccionadas de la siguiente manera:</p> <pre><code>lines = LineCollection sub, sel\nreturn if #lines.lines == 0\nlines\\runCallback ((lines, line, i) -&gt;\n  -- hacer algo con cada l\u00ednea pero en orden\n), true\n</code></pre> <p>Si no te gusta que omita las l\u00edneas comentadas y quieres que se incluyan, recoge las l\u00edneas como se muestra a continuaci\u00f3n:</p> <pre><code>lines = LineCollection sub, sel, (line) -&gt;\n  return true\n</code></pre> <p>De hecho, puedes dar cualquier condici\u00f3n aqu\u00ed y si esa condici\u00f3n se cumple, solo se recoger\u00e1n esas l\u00edneas. Por ejemplo, si solo quieres recoger l\u00edneas comentadas:</p> <pre><code>lines = LineCollection sub, sel, (line) -&gt;\n  return line.comment\n</code></pre> <p>Como ejemplo final, si solo quieres recoger l\u00edneas cuyo layer sea 1:</p> <pre><code>lines = LineCollection sub, sel, (line) -&gt;\n  return line.layer == 1\n</code></pre> <p>Hasta ahora, solo hemos recorrido las l\u00edneas seleccionadas, pero \u00bfqu\u00e9 pasa si queremos recorrer todas las l\u00edneas de di\u00e1logo? Naturalmente, asum\u00ed que <code>lines = LineCollection sub</code> ser\u00eda el camino, pero no funcion\u00f3. As\u00ed que ide\u00e9 una forma algo improvisada:</p> <pre><code>ln = LineCollection sub, sel\nreturn if #ln == 0\nstart = ln[1].number - ln[1].humanizedNumber + 1\nsel = [x for x = start, #sub]\nlines = LineCollection sub, sel\n</code></pre> <p>Esto recorrer\u00e1 todas las l\u00edneas de di\u00e1logo en tu archivo. Obviamente, puedes modificar la \u00faltima l\u00ednea para cambiar el orden del recorrido, as\u00ed como la condici\u00f3n que debe cumplir una l\u00ednea para ser recogida.</p>"},{"location":"programacion/assf/#datos-de-linea","title":"Datos de L\u00ednea","text":"<p>Cuando recorremos cada l\u00ednea, necesitamos crear algo llamado datos de l\u00ednea. Esta es una tabla extensa que ASSFoundation crea despu\u00e9s de analizar una l\u00ednea y consiste en toda la informaci\u00f3n sobre tu l\u00ednea. Todo lo que haremos al usar ASSFoundation es hacer cambios en esta tabla, lo cual a su vez har\u00e1 cambios en la l\u00ednea real. En el siguiente ejemplo, analizamos una l\u00ednea y guardamos sus datos en una variable llamada <code>data</code>.</p> <pre><code>lines\\runCallback (lines, line, i) -&gt;\n  data = ASS\\parse line\n</code></pre> <p>La informaci\u00f3n que contienen los datos de l\u00ednea es:</p> <p>line: tabla de l\u00edneas con todos los campos. scriptInfo: informaci\u00f3n sobre tu subt\u00edtulo como resoluci\u00f3n, matriz de colores, etc. styles: lista de todos los estilos en tu subt\u00edtulo con sus par\u00e1metros. sections: diferentes secciones de una l\u00ednea. Se explica a continuaci\u00f3n.</p>"},{"location":"programacion/assf/#secciones","title":"Secciones","text":"<p>En ASSFoundation, una l\u00ednea puede tener cuatro tipos diferentes de secciones. Sus nombres hacen que sean autoexplicativos, as\u00ed que solo se enumeran aqu\u00ed:</p> <ol> <li>ASS.Section.Text</li> <li>ASS.Section.Tag</li> <li>ASS.Section.Drawing</li> <li>ASS.Section.Comment</li> </ol>"},{"location":"programacion/assf/#metodos-de-foundation","title":"M\u00e9todos de Foundation","text":""},{"location":"programacion/assf/#createline","title":"createLine","text":"<p>Esto crea una nueva l\u00ednea a partir de los datos que proporcionamos. Al crear una l\u00ednea, puedes definir cualquier par\u00e1metro de la tabla de l\u00edneas, como efectos, actor, tiempo de inicio, etc. La l\u00ednea creada se puede a\u00f1adir al subt\u00edtulo usando LineCollection.</p> <p>Si tienes una l\u00ednea de subt\u00edtulo en bruto, puedes crear una l\u00ednea de la siguiente manera:</p> <pre><code>lines = LineCollection sub, sel\nreturn if #lines.lines == 0\nnewLine = ASS\\createLine {\n  \"Dialogue: 0,0:00:00.00,0:00:05.00,Default,,0,0,0,,Test\"\n  lines\n  actor: \"Actor\"\n  start_time: 500\n  end_time: 1000\n  layer: 5\n}\nlines\\addLine newLine\nlines\\insertLines!\n</code></pre> <p>Tambi\u00e9n puedes crear una nueva l\u00ednea basada en la l\u00ednea en la que est\u00e1s trabajando actualmente. Si haces cualquier modificaci\u00f3n a los datos de la l\u00ednea, todos esos cambios se reflejar\u00e1n en la nueva l\u00ednea.</p> <pre><code>lines = LineCollection sub, sel\nlines\\runCallback (lines, line, i) -&gt;\n  data = ASS\\parse line\n  data\\stripTags!                      -- Haz algunos cambios en los datos de la l\u00ednea, por ejemplo, elimina todas las etiquetas de la l\u00ednea. Estos cambios afectar\u00e1n a la nueva l\u00ednea.\n  newLine = ASS\\createLine {\n    line\n    effect: \"Effect\"\n    layer: line.layer - 1\n  }\n  lines\\addLine newLine\nlines\\insertLines!\n</code></pre>"},{"location":"programacion/assf/#createtag","title":"createTag","text":"<p>Puedes crear una nueva instancia de etiqueta que se puede usar en varios lugares en ASSFoundation. Su uso ser\u00e1 claro en la gu\u00eda a continuaci\u00f3n.</p> <pre><code>pos = ASS\\createTag 'position', 5, 50                     -- \\pos(5,50)\nbord = ASS\\createTag 'outline', 5                         -- \\bord5\nblur = ASS\\createTag 'blur', 0.8                          -- \\blur0.8\nmove = ASS\\createTag 'move', 0, 0, 50, 50                 -- \\move(0,0,50,50)\nmove = ASS\\createTag 'move', 0, 0, 50, 50, 25, 500        -- \\move(0,0,50,50,25,500)\nclip_rect = ASS\\createTag 'clip_rect', 50, 50, 500, 500   -- \\clip(50,50,500,500)\ndrawing = ASS\\createTag 'drawing', 1                      -- \\p1\ntransfrom = ASS\\createTag \"transform\", {tags}, t1, t2     -- transforma todas las etiquetas dentro de {tags} desde el tiempo t1 hasta el t2\n\n-- creando Clip Vectorial\nm = ASS.Draw.Move\nl = ASS.Draw.Line\nclip_vect = ASS\\createTag 'clip_vect', {m(0,0), l(500,500), l(700,100)}         -- \\clip(m 0 0 l 500 500 700 100)\n</code></pre>"},{"location":"programacion/assf/#varios-metodos-para-datos-de-linea","title":"Varios M\u00e9todos para Datos de L\u00ednea","text":""},{"location":"programacion/assf/#callback","title":"callback","text":"<p>Una funci\u00f3n que se puede usar para recorrer todas o secciones espec\u00edficas de una l\u00ednea.</p> Par\u00e1metro Significado Predeterminado Tipo sectionClass Tipo de secci\u00f3n a recorrer Si es nil, se recorre todas las secciones de la l\u00ednea. Tipo de Secci\u00f3n ASS start \u00cdndice de la secci\u00f3n desde la que empezar a recorrer (si es negativo, empieza a contar desde el final) 1 entero end \u00cdndice de la secci\u00f3n hasta la que finalizar el recorrido (si es negativo, empieza a contar desde el final) \u00cdndice de la \u00faltima secci\u00f3n de la l\u00ednea entero relative Contar el \u00edndice de inicio relativo al tiempo final false booleano reverse Invertir el orden del recorrido false booleano <pre><code>lines\\runCallback (lines, line, i) -&gt;\n  data = ASS\\parse line\n  data\\callback (section) -&gt;\n    if section.class == ASS.Section.Tag\n      -- hacer algo con las etiquetas\n    elseif section.class == ASS.Section.Text\n      -- hacer algo con el texto\n    elseif section.class == ASS.Section.Comment\n      -- hacer algo con el comentario\n    elseif section.class == ASS.Section.Drawing\n      -- hacer algo con el dibujo\n</code></pre> <p>Si deseas trabajar en una secci\u00f3n individual, puedes hacer lo siguiente:</p> <p>En el siguiente ejemplo, recorremos solo la secci\u00f3n de texto. Puedes reemplazar <code>ASS.Section.Text</code> con cualquier otra secci\u00f3n para recorrer solo esas secciones.</p> <pre><code>data = ASS\\parse line\ndata\\callback ((section) -&gt;\n  -- hacer algo con el texto de la secci\u00f3n\n), ASS.Section.Text\n</code></pre> <p>Recorrer las primeras cinco secciones:</p> <pre><code>data = ASS\\parse line\ndata\\callback ((section) -&gt;\n  -- hacer algo con las etiquetas de la secci\u00f3n\n), nil, 1, 5\n</code></pre> <p>Recorrer solo las primeras secciones de etiqueta dentro del \u00edndice 1 y 5:</p> <pre><code>data = ASS\\parse line\ndata\\callback ((section) -&gt;\n  -- hacer algo con la etiqueta de la secci\u00f3n\n), ASS.Section.Tag, 1, 5\n</code></pre> <p>Recorrer secciones de etiqueta dentro de las \u00faltimas cinco secciones:</p> <pre><code>data = ASS\\parse line\ndata\\callback ((section) -&gt;\n  -- hacer algo con la etiqueta de la secci\u00f3n\n), ASS.Section.Tag, -5\n</code></pre> <p>Usando relative, lo siguiente comenzar\u00e1 desde el \u00edndice '-2' y recorrer\u00e1 hacia atr\u00e1s 5 veces, recorriendo todas las secciones de etiqueta que encuentre.</p> <pre><code>data = ASS\\parse line\ndata\\callback ((section) -&gt;\n  -- hacer algo con la etiqueta de la secci\u00f3n\n), ASS.Section.Tag, -5, -2, true\n</code></pre>"},{"location":"programacion/assf/#geteffectivetags","title":"getEffectiveTags","text":"Par\u00e1metro Significado Tipo index \u00cdndice de la secci\u00f3n de la cual se requiere el valor efectivo de la etiqueta entero includeDefault Incluir el valor de la etiqueta de estilo si no se encuentra la etiqueta de anulaci\u00f3n booleano includePrevious booleano copyTags booleano <p>Puedes usar este m\u00e9todo para obtener el valor efectivo de cualquier etiqueta para una secci\u00f3n en particular. Si la etiqueta no est\u00e1 presente como etiqueta de anulaci\u00f3n, tambi\u00e9n puedes obtener el valor predeterminado del estilo.</p> <pre><code>data = ASS\\parse line\n\n-- Obtener valores de etiquetas efectivas para la \u00faltima secci\u00f3n\ntags = (data\\getEffectiveTags -1, true, true, false).tags\n\n-- Luego puedes obtener un objeto de etiqueta como:\nalign = tags.align\noutline = tags.outline\n\n-- Luego puedes hacer cambios a la etiqueta. Estos cambios se aplicar\u00e1n al \u00edndice que elegiste al obtener las etiquetas efectivas.\n-- Establecer alineaci\u00f3n a 7\nalign\\set 7\n-- A\u00f1adir 5 al borde\noutline\\add 5\n\n-- Aplicar estos cambios a la l\u00ednea\ndata\\commit!\n</code></pre>"},{"location":"programacion/assf/#inserttags","title":"insertTags","text":"Par\u00e1metro Significado Tipo tag Instancia de la etiqueta que deseas insertar objeto de etiqueta index \u00cdndice en el cual insertar la etiqueta. Solo considera secciones de etiquetas entero sectionPosition Posici\u00f3n dentro del bloque de etiquetas donde la etiqueta debe ser insertada entero direct Si es true, intenta insertar etiquetas directamente en el \u00edndice proporcionado. Si la secci\u00f3n no es de tipo etiqueta, falla booleano <p>Este m\u00e9todo se puede usar para insertar una etiqueta en la l\u00ednea. La etiqueta que est\u00e1s insertando debe ser un objeto de etiqueta como lo entiende AssFoundation. Puedes definir el bloque de etiquetas donde deseas insertar la etiqueta, y tambi\u00e9n puedes definir el orden en el que se insertar\u00e1 la etiqueta. Para una l\u00ednea <code>{\\tag1\\tag2}Secci\u00f3n de Texto{\\tag3\\tag4}</code>, 'index' y 'sectionPosition' ser\u00e1n como se muestra en la imagen a continuaci\u00f3n.</p> <p></p> <pre><code>data = ASS\\parse line\n\n-- Obtener valores de etiquetas efectivas para la \u00faltima secci\u00f3n\ntags = (data\\getEffectiveTags -1, true, true, false).tags\n\n-- Insertar ese valor de etiqueta en la l\u00ednea\ndata\\insertTags tags.shadow       -- A\u00f1ade \\shad al primer bloque de etiquetas\ndata\\insertTags tags.scale_x, 2   -- A\u00f1ade \\fscx al segundo bloque de etiquetas\ndata\\insertTags tags.scale_y, -1  -- A\u00f1ade \\fscy al \u00faltimo bloque de etiquetas\n</code></pre>"},{"location":"programacion/assf/#getdefaulttags","title":"getDefaultTags","text":"Par\u00e1metro Significado Tipo Predeterminado style Estilo para obtener el valor string Estilo de la l\u00ednea actual copyTags booleano true useOvrAlign Considerar la etiqueta de alineaci\u00f3n para obtener la posici\u00f3n actual booleano true <p>Este m\u00e9todo se puede utilizar para obtener los valores de las etiquetas en el estilo. Por defecto, encuentra las etiquetas de la l\u00ednea actual, pero podemos pasar cualquier estilo presente en los subt\u00edtulos para obtener el valor de la etiqueta de ese estilo.</p> <pre><code>data = ASS\\parse line\nstyleTags = (data\\getDefaultTags!).tags\n\n-- Luego podemos acceder a una tabla para cada etiqueta de la siguiente manera\nangleTable = styleTags.angle\n\n-- Podemos obtener directamente el valor de la etiqueta as\u00ed:\nangle = styleTags.angle\\get!\n</code></pre>"},{"location":"programacion/assf/#insertdefaulttags","title":"insertDefaultTags","text":"Par\u00e1metro Significado Tipo tagnames Nombres de la etiqueta o tabla con nombres de etiquetas string o tabla index \u00cdndice en el cual insertar la etiqueta. Solo considera secciones de etiquetas entero sectionPosition Posici\u00f3n dentro del bloque de etiquetas donde la etiqueta debe ser insertada entero direct Si es true, intenta insertar etiquetas directamente en el \u00edndice proporcionado. Si la secci\u00f3n no es de tipo etiqueta, falla booleano <p>Este m\u00e9todo inserta los valores de estilo de una etiqueta directamente en la l\u00ednea.</p> <pre><code>data = ASS\\parse line\n\n-- Insertar una \u00fanica etiqueta en el primer bloque de etiquetas. Si el primer bloque de etiquetas no existe, se agrega uno.\ndata\\insertDefaultTags \"align\"\n\n-- Insertar m\u00faltiples etiquetas en el primer bloque de etiquetas\ndata\\insertDefaultTags {\"scale_x\", \"scale_y\", \"blur\"}\n\n-- Insertar la etiqueta en el segundo bloque de etiquetas. Si el segundo bloque de etiquetas no existe, no sucede nada.\ndata\\insertDefaultTags \"fontname\", 2\n\n-- Dado que direct es true, intenta encontrar la tercera secci\u00f3n. Si la tercera secci\u00f3n no existe o no es una secci\u00f3n de etiquetas, genera un error.\ndata\\insertDefaultTags \"outline\", 3, nil, true\n</code></pre> <p>Una forma de cambiar el valor de la etiqueta predeterminada que insertaste es:</p> <pre><code>data = ASS\\parse line\nblur = data\\insertDefaultTags \"blur\"      -- Insertar el valor predeterminado de blur\nblur.value = 5                            -- Cambiar el valor de la etiqueta que ya has insertado\ndata\\commit!\n</code></pre>"},{"location":"programacion/assf/#cleantags","title":"cleanTags","text":"<p>Este m\u00e9todo se usa para limpiar, ordenar y fusionar etiquetas en una l\u00ednea.</p> Par\u00e1metro Significado Tipo Predeterminado level Explicado a continuaci\u00f3n entero 3 mergeConsecutiveSections Fusionar secciones de etiquetas consecutivas booleano true defaultToKeep Evita la eliminaci\u00f3n de estas etiquetas tabla {} tagSortOrder Determina el orden en que se ordenar\u00e1n las etiquetas limpiadas dentro de una secci\u00f3n de etiquetas. Resets siempre van primero, transforms al final tabla {} <p>Niveles de Limpieza:</p> <ul> <li>0: Sin limpieza</li> <li>1: Eliminar secciones de etiquetas vac\u00edas</li> <li>2: Eliminar etiquetas duplicadas dentro de secciones</li> <li>3: Eliminar etiquetas duplicadas globalmente</li> <li>4: Eliminar etiquetas que coinciden con los valores predeterminados del estilo y otras etiquetas inefectivas</li> </ul> <pre><code>data = ASS\\parse line\ndata\\cleanTags!                                         -- Limpiar etiquetas usando los valores predeterminados de los par\u00e1metros\ndata\\cleanTags 1                                        -- Limpiar etiquetas usando el nivel de limpieza 1\n</code></pre> <p>ASSFoundation ofrece una tabla para ordenar etiquetas. El orden de las etiquetas es el siguiente:</p> <pre><code>{\"align\", \"position\", \"move\", \"origin\", \"scale_x\", \"scale_y\", \"angle\", \"angle_y\", \"angle_x\", \"shear_x\", \"shear_y\", \"fontname\", \"fontsize\", \"spacing\", \"bold\", \"italic\", \"underline\", \"strikeout\", \"outline\", \"outline_x\", \"outline_y\", \"shadow\", \"shadow_x\", \"shadow_y\", \"color1\", \"color2\", \"color3\", \"color4\", \"alpha\", \"alpha1\", \"alpha2\", \"alpha3\", \"alpha4\", \"blur\", \"blur_edges\", \"fade_simple\", \"fade\", \"clip_rect\", \"iclip_rect\", \"clip_vect\", \"iclip_vect\", \"wrapstyle\", \"drawing\", \"k_fill\", \"k_sweep\", \"k_bord\", \"junk\", \"unknown\"}\n</code></pre> <pre><code>data\\cleanTags nil, nil, nil, ASS.tagSortOrder\n</code></pre> <p>Si deseas definir tu propio orden, aseg\u00farate de que tagSortOrder incluya todas las etiquetas de la tabla, ya que si omites alguna, ser\u00e1 eliminada durante la limpieza. Las etiquetas en la tabla tagSortOrder deben ser los nombres de las etiquetas seg\u00fan lo entendido por ASSFoundation. Debes reorganizar la tabla de etiquetas anterior seg\u00fan c\u00f3mo te convenga. Sin embargo, puedes convertir los nombres de las etiquetas de sobrescritura como se muestra a continuaci\u00f3n.</p> <pre><code>-- Primero define una tabla con las etiquetas en el orden que deseas\ntagSortOrder = {\"\\\\an\", \"\\\\pos\", \"\\\\move\", \"\\\\org\", \"\\\\fscx\", \"\\\\fscy\", \"\\\\frz\", \"\\\\fry\", \"\\\\frx\", \"\\\\fax\", \"\\\\fay\", \"\\\\fn\", \"\\\\fs\", \"\\\\fsp\", \"\\\\b\", \"\\\\i\", \"\\\\u\", \"\\\\s\", \"\\\\bord\", \"\\\\xbord\", \"\\\\ybord\", \"\\\\shad\", \"\\\\xshad\", \"\\\\yshad\", \"\\\\1c\", \"\\\\2c\", \"\\\\3c\", \"\\\\4c\", \"\\\\alpha\", \"\\\\1a\", \"\\\\2a\", \"\\\\3a\", \"\\\\4a\", \"\\\\blur\", \"\\\\be\", \"\\\\fad\", \"\\\\fade\", \"clip_rect\", \"iclip_rect\", \"clip_vect\", \"iclip_vect\", \"\\\\q\", \"\\\\p\", \"\\\\k\", \"\\\\kf\", \"\\\\K\", \"\\\\ko\", \"junk\", \"unknown\"}\n\n-- Convierte los nombres de las etiquetas de sobrescritura a los nombres de etiquetas entendidos por ASSFoundation\ntagSortOrder = ASS\\getTagNames tagSortOrder\n\n-- Luego \u00fasalos en cleanTags\ndata\\cleanTags nil, nil, nil, tagSortOrder\n</code></pre>"},{"location":"programacion/assf/#removetags","title":"removeTags","text":"<p>Este m\u00e9todo se puede utilizar para eliminar etiquetas ya presentes en la l\u00ednea.</p> Par\u00e1metro Significado Tipo tags nombre de la etiqueta o tabla de nombres de etiquetas string o tabla start \u00edndice de la secci\u00f3n desde la cual comenzar a eliminar etiquetas entero end \u00edndice de la secci\u00f3n hasta la cual eliminar etiquetas entero relative booleano <pre><code>data = ASS\\parse line\n\n-- Puedes pasar un nombre de etiqueta \u00fanico para eliminarlo. Esto elimina \\bord de todos los bloques de etiquetas.\ndata\\removeTags \"outline\"\n\n-- Puedes pasar una tabla de nombres de etiquetas para eliminarlas todas.\ndata\\removeTags {\"align\", \"blur\"}\n\n-- Elimina la etiqueta blur del primer bloque de etiquetas.\ndata\\removeTags \"blur\", 1, 1\n\n-- Elimina la etiqueta blur del segundo al quinto bloque de etiquetas.\ndata\\removeTags \"blur\", 2, 5\n\n-- Elimina \\shad del \u00faltimo bloque de etiquetas.\ndata\\removeTags \"shadow\", -1\n</code></pre> <p>Despu\u00e9s de eliminar etiquetas usando removeTags, podr\u00edan quedar llaves {} sueltas si esa es la \u00fanica etiqueta en ese bloque de etiquetas. Se recomienda usar cleanTags para eliminarlas.</p> <p>Si deseas eliminar una etiqueta pero al mismo tiempo modificarla de alguna manera, es muy \u00fatil guardar la etiqueta en una variable utilizando removeTags. Una vez guardada en una variable, esta variable puede ser manipulada por separado mientras la etiqueta se habr\u00e1 eliminado de la l\u00ednea.</p> <pre><code>path = data\\removeTags({\"clip_vect\", \"iclip_vect\"})\n</code></pre>"},{"location":"programacion/assf/#replacetags","title":"replaceTags","text":"Par\u00e1metro Significado Tipo tagList Instancia de etiqueta que deseas reemplazar. objeto de etiqueta de ASSFoundation start \u00cdndice de la secci\u00f3n desde la cual comenzar a reemplazar etiquetas. entero end \u00cdndice de la secci\u00f3n hasta la cual reemplazar etiquetas. entero relative Si es true, solo se consideran las secciones de etiqueta (es decir, el \u00edndice 2 significa la segunda secci\u00f3n de etiqueta, no la segunda secci\u00f3n literal de la l\u00ednea). booleano insertRemaining Si es true (por defecto), si la etiqueta que est\u00e1s reemplazando no existe en la l\u00ednea, se agrega la etiqueta a la l\u00ednea en lugar de reemplazar la existente. booleano <p>Este m\u00e9todo inserta los valores de estilo de una etiqueta directamente en la l\u00ednea.</p> <pre><code>data = ASS\\parse line\n\n-- Define objetos de etiquetas \\bord y \\shad\nbord = ASS\\createTag \"outline\", 5\nshad = ASS\\createTag \"shadow\", 10\n\n-- Reemplaza todas las etiquetas bord\ndata\\replaceTags bord\n\n-- Reemplaza bord desde el segundo hasta el quinto bloque de etiquetas\ndata\\replaceTags bord, 2, 5, true\n\n-- Reemplaza la etiqueta bord solo si existe en la l\u00ednea\ndata\\replaceTags bord, _, _, _, false\n\n-- Reemplaza m\u00faltiples etiquetas a la vez pasando una tabla de etiquetas\ndata\\replaceTags {bord, shad}\n</code></pre> <p>Tambi\u00e9n puedes crear una nueva instancia de etiqueta y reemplazarla en una sola l\u00ednea.</p> <pre><code>data = ASS\\parse line\ndata\\replaceTags {ASS\\createTag \"angle\", 5}\ndata\\commit!\n</code></pre>"},{"location":"programacion/assf/#modificacion-de-texto","title":"Modificaci\u00f3n de texto","text":""},{"location":"programacion/assf/#cambiar-todo-el-texto","title":"Cambiar todo el texto","text":""},{"location":"programacion/assf/#anadir-al-texto-existente","title":"A\u00f1adir al texto existente","text":""},{"location":"programacion/assf/#anteponer-al-texto-existente","title":"Anteponer al texto existente","text":""},{"location":"programacion/mas-sobre-lua/","title":"M\u00e1s sobre programaci\u00f3n en Lua","text":"<p>Sigo escuchando a la gente decir \"Necesito aprender algo de Lua\" o \"Necesito aprender a escribir scripts de automatizaci\u00f3n\", y no muchos parecen haberse adentrado realmente en ello. Esto deber\u00eda ayudarte a empezar. Deber\u00edas leer la gu\u00eda de Lyger primero, porque no voy a explicar las mismas cosas de nuevo, pero quiero proporcionar algunos consejos m\u00e1s pr\u00e1cticos. En lugar de explicar Lua en s\u00ed mismo, explicar\u00e9 m\u00e1s sobre los scripts para Aegisub espec\u00edficamente.</p> <p>Aprender Lua no es gran cosa. Puedes aprender todo lo que necesitas de Lua en una hora. Principalmente son solo if/then/end, el ciclo for, gsub, y algunas otras cosas.</p> <p>Una gran parte de lo que necesitas son expresiones regulares, o m\u00e1s bien, la coincidencia de patrones simplificada de Lua. Eso, nuevamente, es algo que puedes aprender en una hora.</p> <p>Lo que m\u00e1s quiero hablar es c\u00f3mo trabajar con el objeto Subtitles, que no es realmente un asunto de Lua, sino m\u00e1s bien de Aegisub y el formato ASS. Esto se explica en el manual de Aegisub, pero como eso puede ser confuso para los principiantes, proporcionar\u00e9 algunos ejemplos pr\u00e1cticos espec\u00edficos. El objetivo es explicar c\u00f3mo escribir un script de automatizaci\u00f3n b\u00e1sica en los t\u00e9rminos m\u00e1s simples posibles. Una vez que comprendas c\u00f3mo funciona un script que agrega desenfoque, agregar funciones m\u00e1s complejas ser\u00e1 f\u00e1cil porque eso es solo matem\u00e1ticas.</p> <p>Aqu\u00ed est\u00e1 lo b\u00e1sico:</p> <pre><code>script_name=\"prueba\" \nscript_description=\"probando cosas\" \nscript_author=\"alguien\" \nscript_version=\"1\"\n\nfunction test(subs, sel, act) \n    -- aqu\u00ed va el c\u00f3digo \nend\n\naegisub.register_macro(script_name, script_description, test)\n</code></pre> <p>La \u00faltima l\u00ednea coloca una entrada en tu men\u00fa de automatizaci\u00f3n. Tiene 3 partes. Dos de ellas se definen al principio: script_name y script_description. El nombre aparecer\u00e1 en el men\u00fa y como una entrada de deshacer cuando ejecutes el script. Puedes ver la descripci\u00f3n en el Administrador de Automatizaci\u00f3n. La tercera parte significa que al ejecutar este script se ejecutar\u00e1 una funci\u00f3n llamada \"test\".</p> <p>script_author y script_version no son realmente importantes, pero estoy seguro de que captas la idea.</p> <p>Veamos la funci\u00f3n test(subs, sel, act). Probablemente escrib\u00ed al menos 20 scripts antes de entender realmente qu\u00e9 es esto. Dado que esta funci\u00f3n es referenciada por register_macro, es la funci\u00f3n principal del script y, como tal, se le da por defecto el objeto Subtitles para trabajar. Las 3 partes \u2014 subt\u00edtulos, l\u00edneas seleccionadas y l\u00ednea activa \u2014 te dan 3 cosas con las que puedes trabajar.</p> <p>Puedes nombrarlas como quieras. Solo tienes que seguir con la nomenclatura. Tiendo a mantener todo corto, aunque estoy seguro de que no soy el \u00fanico que usa subs/sel/act. Probablemente sea mejor usar estos incluso solo por el hecho de que otros tambi\u00e9n lo hacen, lo que facilita entender los scripts de los dem\u00e1s.</p> <p>subs es todo el objeto de subt\u00edtulos. Siempre tienes que usar esto. En t\u00e9rminos simples, es como una tabla de todas las l\u00edneas en el script ASS, incluyendo encabezados, estilos, etc.</p> <p>sel son las l\u00edneas seleccionadas, y si quieres que tu funci\u00f3n se aplique a todas las l\u00edneas, no tienes que usar esto. Puedes tener function test(subs).</p> <p>act es la l\u00ednea activa, y probablemente no la necesitar\u00e1s muy a menudo. Puedes usarla para funciones que se supone deben ejecutarse en solo una l\u00ednea o leer alguna informaci\u00f3n de la l\u00ednea activa. Si seleccionas una l\u00ednea y usas sel, es pr\u00e1cticamente lo mismo que usar act.</p> <p>La parte \"aqu\u00ed va el c\u00f3digo\" es donde se escribir\u00e1 la funci\u00f3n real.</p> <p>Aqu\u00ed tienes un ejemplo de una funci\u00f3n simple que se ejecuta en todo el script:</p> <pre><code>function test(subs)\n    for i=1,#subs do\n        if subs[i].class==\"dialogue\" then\n            line=subs[i]\n            text=subs[i].text\n\n        line.effect=\"test\"\n\n        line.text=text\n            subs[i]=line\n    end\n    end\n    aegisub.set_undo_point(script_name)\nend\n</code></pre> <p>La parte verde es lo que normalmente tendr\u00e1s en cada script que se ejecuta en todas las l\u00edneas. La parte morada es la funci\u00f3n espec\u00edfica real.</p> <p>#subs es cu\u00e1ntas l\u00edneas hay en subs (incluyendo encabezados y todo). Si el archivo ASS tiene 200 l\u00edneas, el ciclo for se ejecutar\u00e1 200 veces. Solo quieres aplicar esto a las l\u00edneas de di\u00e1logo, no a los estilos o encabezados, as\u00ed que debes especificar esta condici\u00f3n: if subs[i].class==\"dialogue\".</p> <p>Entonces, el iterador i va de 1 a 200, as\u00ed que cuando sea, digamos, 25, subs[i] es subs[25], o la 25\u00aa l\u00ednea en el archivo ASS. line=subs[i] significa que creas el elemento line y colocas subs[i] en \u00e9l. Ten en cuenta que un solo = no significa \"igual\". Podr\u00edas leerlo como \"l\u00ednea ahora es subs[25]\" (cuando i es 25). Luego trabajas con line, y para que tenga alg\u00fan uso, debes volver a colocar la line en subs[i] al final. line es algo que creaste, subs[i] es la l\u00ednea real en los subt\u00edtulos, as\u00ed que necesitas subs[i]=line al final.</p> <p>Ves lo mismo con text, aunque en este caso no lo necesito, pero generalmente trabajas m\u00e1s con text. El prop\u00f3sito es usar algo que sea corto en lugar de escribir subs[i].text todo el tiempo. Adem\u00e1s, tambi\u00e9n podr\u00eda decir text=line.text ya que line ya est\u00e1 definida en ese punto. Puedes nombrar esas cosas como quieras, por ejemplo solo l y t, lo que puede ser bueno para un script corto, pero nuevamente, line y text son com\u00fanmente usados por la mayor\u00eda de nosotros, as\u00ed que mantiene las cosas claras.</p> <p>aegisub.set_undo_point(script_name) establece el punto de deshacer, y deber\u00eda estar al final de la funci\u00f3n principal, aunque creo que Aegisub lo hace autom\u00e1ticamente de todos modos. Sin embargo, puedes crear m\u00faltiples puntos de deshacer, como para cada funci\u00f3n en tu script, pero generalmente solo es confuso y no muy pr\u00e1ctico.</p> <p>Ahora, lo que realmente hace este script es line.effect=\"test\". line.effect es el campo de efecto, y aqu\u00ed toma el valor \"test\", lo que significa que el texto del campo de efecto ser\u00e1 \"test\". Entonces, lo que hace este script es poner \"test\" en el campo de efecto de cada l\u00ednea de di\u00e1logo.</p> <p>Ahora, lo que hice aqu\u00ed con text habr\u00eda tenido m\u00e1s sentido si lo hubiera hecho con \"efecto\" en su lugar (porque en realidad no hice nada con texto), es decir, effect=line.effect. Luego, la l\u00ednea morada podr\u00eda ser solo effect=\"test\". Siempre debes pensar en lo que vale la pena y lo que no. Para este script, la l\u00ednea morada ser\u00eda 5 caracteres m\u00e1s corta, pero necesitar\u00edas dos l\u00edneas adicionales, para asignar el valor al effect y para devolver el valor a line.effect, as\u00ed que eso no vale la pena. Si usas algo solo una vez, igual puedes mantenerlo como est\u00e1. Cuanto m\u00e1s uses algo, m\u00e1s sentido tiene asignarlo a algo con un nombre corto.</p> <p>Ahora, veamos c\u00f3mo trabajar con las l\u00edneas seleccionadas.</p> <pre><code>function test(subs, sel)\n    for x, i in ipairs(sel) do\n        line=subs[i]\n        text=line.text\n\n    if text:match(\"tu corbata est\u00e1 torcida\") then line.effect=\"el editor es un idiota\" end\n\n    line.text=text\n        subs[i]=line\n    end\n    aegisub.set_undo_point(script_name)\n    return sel\nend\n</code></pre> <p>Soy demasiado perezoso para hacer html de alto esfuerzo, pero puedes pegar el c\u00f3digo en Notepad++ para un resaltado de sintaxis adecuado. Puedes ver que el ciclo for est\u00e1 usando ipairs. sel consiste en pares de dos n\u00fameros. El primero es el \u00edndice de la selecci\u00f3n, y el segundo es el \u00edndice en subs. Si el archivo ASS tiene 50 l\u00edneas y seleccionas las \u00faltimas 3, entonces el x en ipairs ser\u00e1 1, 2 y 3, e i ser\u00e1 48, 49 y 50. En el ejemplo anterior, x e i son lo mismo porque recorre todas las l\u00edneas.</p> <p>No olvides que la funci\u00f3n debe tener (subs, sel). Por supuesto, siempre puedes incluir el sel incluso si no lo est\u00e1s usando, solo para asegurarte de que nunca lo olvides. Casi siempre uso (subs, sel) y en casos raros agrego act.</p> <p>La l\u00ednea morada es un ejemplo b\u00e1sico de una acci\u00f3n dependiente de una condici\u00f3n. Puedes leerlo como: Si encuentras \"tu corbata est\u00e1 torcida\" en el text, pon \"el editor es un idiota\" en el effect.</p> <p>return sel se asegura de que mantengas la selecci\u00f3n con la que comenzaste (o una nueva selecci\u00f3n si la cambiaste).</p> <p>Tambi\u00e9n podr\u00edas usar for i=1,#sel do en lugar de ipairs, como hicimos con subs. Si tu script est\u00e1 eliminando o agregando l\u00edneas, necesitas ir hacia atr\u00e1s, porque las l\u00edneas nuevas/eliminadas est\u00e1n cambiando el \u00edndice de las l\u00edneas seleccionadas. Si eliminas la l\u00ednea 1, la l\u00ednea 2 se convierte en la l\u00ednea 1 y la l\u00ednea 3 se convierte en la l\u00ednea 2, por lo que yendo en la direcci\u00f3n normal, estar\u00edas omitiendo l\u00edneas o pasando por ellas dos veces.</p> <pre><code>for i=#sel,1,-1 do\n        local line=subs[sel[i]]\n\n    ...\n\n    subs[sel[i]]=line\n</code></pre> <p>Este es el uso que le doy. Comienza en la \u00faltima l\u00ednea seleccionada y va hacia atr\u00e1s hasta la primera. i=a,b,c significa que va desde a hasta b en pasos de c. i=8,2,-2 recorrer\u00eda las l\u00edneas 8, 6, 4, 2. El valor predeterminado para los pasos es 1, as\u00ed que a menos que vayas hacia atr\u00e1s como aqu\u00ed, no necesitas escribirlo.</p> <p>Una cosa importante es que si usas esto, entonces la line es subs[sel[i]], no subs[i]. Aqu\u00ed i es el n\u00famero de la l\u00ednea seleccionada, comenzando desde 1, as\u00ed que si usas subs[i] cuando i es 1, tendr\u00edas la primera l\u00ednea en el archivo ASS, no la primera l\u00ednea seleccionada. sel[3] es el n\u00famero en subs correspondiente a la tercera l\u00ednea seleccionada.</p> <p>Esta cuesti\u00f3n me confundi\u00f3 durante bastante tiempo, as\u00ed que intentemos un ejemplo m\u00e1s espec\u00edfico. Digamos que subs tiene 50 l\u00edneas (incluyendo encabezados y estilos) y seleccionas las \u00faltimas 5 l\u00edneas. sel ser\u00eda ahora {46,47,48,49,50}.  sel[1]==46  sel[2]==47  sel[5]==50  Usar el ciclo for ir\u00e1 de 1 a 5, por lo que i ser\u00e1 1-5, y sel[i] ser\u00e1 46-50. subs[i] ser\u00edan las l\u00edneas 1-5, lo cual no es lo que quieres. subs[sel[i]] ser\u00e1n las l\u00edneas 46-50. Eso es lo que necesitas.</p> <p>Entonces, eso m\u00e1s o menos cubre la estructura de la funci\u00f3n principal. Con esto y un mont\u00f3n de l\u00edneas if/then/end puedes hacer scripts simples.</p> <p>Ahora, veamos algunas formas de manipular text.</p> <pre><code>text=text..\" fin de l\u00ednea\"\n</code></pre> <p>Esto adjunta una cadena al final del text.</p> <pre><code>text=\"Inicio de l\u00ednea \"..text\n</code></pre> <p>Esto adjunta una cadena al principio del text. De esta manera puedes agregar etiquetas:</p> <pre><code>text=\"{\\\\blur0.6}\"..text\n</code></pre> <p>As\u00ed es como funcionaba el antiguo script \"Agregar desenfoque de borde\". Por supuesto, esto no lo une con otras etiquetas, no reemplaza el blur existente, etc.</p> <pre><code>text=\"Esto es una prueba.\"\ntext=\"\"\n</code></pre> <p>Aqu\u00ed, el primer c\u00f3digo establece \u00abEsto es una prueba.\u00bb como texto, eliminando lo que hab\u00eda antes. El segundo simplemente elimina el texto, convirti\u00e9ndolo en una cadena vac\u00eda.</p>"},{"location":"programacion/mas-sobre-lua/#gsub","title":"gsub","text":"<p>gsub es pr\u00e1cticamente el n\u00facleo de cada script de automatizaci\u00f3n. Es lo que reemplaza una cosa por otra. Funciona as\u00ed:</p> <pre><code>text2=text:gsub(\"cadena A\",\"cadena B\")\n</code></pre> <p>Esto se traduce en: Si encuentras \"cadena A\" en text, reempl\u00e1zala con \"cadena B\" y asigna el text modificado a text2. Us\u00e9 text2 para la explicaci\u00f3n, pero normalmente usar\u00edas text=text:gsub, lo que simplemente mantiene el resultado en text.</p> <p>\"No podia verlo.\"</p> <pre><code>text=text:gsub(\"No podia\",\"No pod\u00eda\")\n</code></pre> <p>\u2192 \"No pod\u00eda verlo.\"</p> <p>De esta manera, por ejemplo, puedes escribir un script para hacer reemplazos.</p> <pre><code>text=text\n:gsub(\"aqu\u00e9([lloa]s?)\",\"aque%1\")\n:gsub(\"no lo s\u00e9\",\"no s\u00e9\")\n:gsub(\"no ha sido\",\"no fue\")\n</code></pre> <p>Solo necesitas la parte text=text una vez. Luego puedes agregar tantas l\u00edneas :gsub como desees y crear una lista completa de contracciones. Mientras puedes simplemente agregarlas una por una, tambi\u00e9n puedes usar el patr\u00f3n de coincidencia (la versi\u00f3n de Lua de expresiones regulares) para mantener el c\u00f3digo corto. La primera l\u00ednea gsub coincidir\u00e1 con aqu\u00e9l, aqu\u00e9lla, aqu\u00e9llo, aqu\u00e9llas y aqu\u00e9llos. Tambi\u00e9n coincidir\u00e1 con aqu\u00e9los y aqu\u00e9las, pero como esas no existen, eso no nos molesta. La parte entre par\u00e9ntesis es una captura. [lloa] significa \"l o ll o o o a\", y s? significa \"s si est\u00e1 ah\u00ed o nada si no lo est\u00e1\". En las expresiones regulares est\u00e1ndar podr\u00edas reemplazar esta captura con (l|ll|o|a|os|as) para obtener el mismo resultado. Lua no tiene esta opci\u00f3n, as\u00ed que a veces necesitas m\u00e1s l\u00edneas de las que necesitar\u00edas con expresiones regulares completas. El %1 es la captura, por lo que cualquier cosa que coincida en la primera parte se pegar\u00e1 en la segunda.</p> <p>Ahora podemos usar esto para reemplazar el valor de blur existente con nuestro nuevo valor.</p> <pre><code>text=text:gsub(\"\\\\blur[%d%.]+\",\"\\\\blur0.6\")\n</code></pre> <p>El desenfoque puede tener n\u00fameros y un punto decimal, as\u00ed que usa [%d%.]+ para coincidir con cualquier cosa que sea un n\u00famero o un punto tantas veces seguidas como sea posible, de modo que cualquier valor que tenga el desenfoque se reemplazar\u00e1 con 0.6. El mismo efecto podr\u00eda lograrse de diferentes maneras:</p> <pre><code>text=text:gsub(\"(\\\\blur)[%d%.]+\",\"%10.6\") \ntext=text:gsub(\"\\\\blur[^\\\\}]+\",\"\\\\blur0.6\"))\n</code></pre> <p>El primero captura la parte \\\\blur, para que no tengas que volver a escribirla (puede ser \u00fatil si es algo m\u00e1s largo). El segundo coincide con cualquier cosa que no sea una barra invertida o } tantas veces como pueda, es decir, hasta que encuentre algo que SEA una barra invertida o }, que es donde l\u00f3gicamente terminar\u00eda el valor de blur. Esto puede capturar de manera bastante eficiente todo el valor de cualquier etiqueta, ya que cualquier etiqueta tiene que terminar con \\ o }. Por supuesto, con etiquetas como \\pos, querr\u00e1s capturar las coordenadas en lugar de incluir los ().</p> <p>Tambi\u00e9n puedes usar una funci\u00f3n dentro de gsub:</p> <pre><code>text=text:gsub(\"(\\\\blur)([%d%.]+)\",function(a,b) return a .. 2*b end)\n</code></pre> <p>a y b son las capturas. La funci\u00f3n las usa, devolviendo a (\\\\blur) tal como est\u00e1, y multiplicando b por 2, d\u00e1ndote el valor de desenfoque duplicado. As\u00ed que puedes dividir tu patr\u00f3n en un mont\u00f3n de capturas y hacer algunas operaciones con ellas.</p> <p>As\u00ed es como capitalizas la primera letra de una l\u00ednea:</p> <pre><code>text=text:gsub(\"^(%l)([^{]-)\", function (c,d) return c:upper()..d end)\n</code></pre> <p>La primera captura es una letra min\u00fascula al principio de una l\u00ednea. La segunda captura es desde despu\u00e9s de la primera letra hasta {, lo que significa antes de encontrar un comentario o etiqueta. Se devuelve la primera captura en may\u00fascula y la segunda captura tal como est\u00e1 (lo que significa que ni siquiera tiene que estar all\u00ed en este caso, pero podr\u00edas, por ejemplo, devolver d:lower() para asegurarte de que el resto de la cadena sea en min\u00fasculas).</p> <p>Ahora puedes entender c\u00f3mo funciona mi Teletransportador:</p> <pre><code>text=text:gsub(\"\\\\pos%(([%d%.%-]+),([%d%.%-]+)%)\",function(a,b) return \"\\\\pos(\".. a+xx.. \",\" ..b+yy..\")\" end)\n</code></pre> <p>Observa que los par\u00e9ntesis literales ( y ), es decir, no capturas, deben escaparse con %. Las capturas de coordenadas son [%d%.%-]+. Ves que en comparaci\u00f3n con lo que ten\u00edamos para el desenfoque, estas incluyen %- porque las coordenadas pueden ser negativas. Si no incluyes eso, el script solo funcionar\u00e1 cuando las coordenadas sean positivas. Por lo tanto, captura las coordenadas X e Y, y les suma la entrada del usuario, que aqu\u00ed es xx e yy. S\u00ed, as\u00ed de simple.</p> <p>Un ejemplo m\u00e1s. Este es un \"movimiento inverso\":</p> <pre><code>text=text:gsub(\"\\\\move%(([%d%.%-]+),([%d%.%-]+),([%d%.%-]+),([%d%.%-]+)\",\"\\\\move(%3,%4,%1,%2\")\n</code></pre> <p>Eso es todo. Captura las 4 coordenadas y las devuelve en orden cambiado: 3, 4, 1, 2. Este es un buen ejemplo de c\u00f3mo pueden ser \u00fatiles las capturas. Puede que notes que el ( no est\u00e1 escapado en la mitad derecha. Las cosas en la parte derecha de gsub no necesitan ser escapadas con %: solo se usa para capturas. Solo la parte izquierda usa expresiones regulares.</p>"},{"location":"programacion/mas-sobre-lua/#caracteres-de-escape","title":"Caracteres de escape","text":"<p>Cuando se utiliza expresiones regulares, estos caracteres deben ser escapados con %: . ? * - + ( ) [ ] y el propio %.</p> <p>Caracteres que deben ser escapados con \\: \" ' y el propio \\</p> <p>Las barras invertidas y las comillas siempre deben ser escapadas, incluso en cadenas literales. (Una comilla real termina la cadena). Si deseas hacer coincidir un signo de interrogaci\u00f3n real en una oraci\u00f3n, debes hacer coincidir %?.</p>"},{"location":"programacion/mas-sobre-lua/#expresiones-regulares","title":"Expresiones Regulares","text":"<p>No voy a explicar las expresiones regulares desde cero, porque hay mucha informaci\u00f3n sobre eso en Internet. Lo que voy a hacer es listar algunos patrones que son \u00fatiles para los scripts de automatizaci\u00f3n en Aegisub.</p> <pre><code>{[^\\\\}]-}   -- comentario (cosas entre { y } que no tienen una barra invertida)\n{\\\\[^}]-}   -- etiquetas (cosas entre { y } que comienzan con una barra invertida)\n{[^}]-}     -- comentario o etiquetas (cosas entre { y })\n</code></pre> <p>El tercero te muestra una manera t\u00edpica de hacer coincidir cosas entre dos marcadores. Haces coincidir el primer marcador, luego lo-que-no-es-el-segundo-marcador con un - o *, y luego el segundo marcador. La diferencia entre - y * es que {.-} coincide solo con un comentario o conjunto de etiquetas, mientras que {.}, si tienes una cadena como \"abc{def}ghi{jkl}\" coincidir\u00e1 desde el primer { hasta el \u00faltimo }, as\u00ed \"{def}ghi{jkl}\". Siempre tienes que pensar si necesitas +, -, o *. Si eliges el incorrecto, a\u00fan puede funcionar en casos simples, como si solo hay un comentario en la l\u00ednea, pero fallar\u00e1 en l\u00edneas m\u00e1s complejas. Recomiendo crear un archivo ASS de prueba y llenarlo con todo tipo de l\u00edneas diferentes, incluidos errores, etiquetas malas, comentarios rotos, etc. Ten todas las combinaciones de texto, etiquetas y comentarios, usa algunas transformaciones, algunas l\u00edneas de mocha, cualquier cosa que pueda estar en un script. Si escribes una funci\u00f3n, necesita hacer lo que se supone que debe hacer sin importar a qu\u00e9 l\u00ednea se aplique.</p> <pre><code>%d+     -- secuencia de n\u00fameros\n[%d%.]+     -- secuencia de n\u00fameros, puede tener punto decimal (valores de \\bord, \\blur, \\fscx, etc.)\n[%d%.%-]+   -- secuencia de n\u00fameros, puede tener punto decimal, puede ser negativo (\\xshad, \\fsp, \\frz...)\n&amp;H%x+&amp;      -- valores para colores y alfa\n%([^%)]-%)  -- cosas entre ( y )\n\n%(([%d%.%-]+),([%d%.%-]+)%)\n</code></pre> <p>Esto capturar\u00e1 las coordenadas de \\pos o \\org. Tambi\u00e9n podr\u00eda capturar el desvanecimiento de entrada y de salida en (\\fad), aunque no es necesario el '-'. Para \\move, captura 4 coordenadas y no incluyas el % final, porque \\move puede o no tener c\u00f3digos de tiempo.</p> <pre><code>[%a']+ -- palabra (secuencia de letras o ap\u00f3strofes, para coincidir con palabras como \"don't\") \n[^%s]+ -- palabra (secuencia de lo que no es un espacio) \n</code></pre> <p>Es posible que necesites diferentes maneras de coincidir con una palabra. El primero de estos patrones no incluir\u00e1 la puntuaci\u00f3n, el segundo s\u00ed. A veces necesitar\u00e1s uno, a veces el otro. Tambi\u00e9n podr\u00edas querer reemplazar %a con %w, si deseas incluir \"palabras\" como AK47 o simplemente contar 20 en \"I'm 20 years old.\" como una palabra.</p> <p>\\[1234]?c&amp; -- etiqueta de color (no coincide con el valor, solo verifica que la etiqueta est\u00e9 presente) Esto coincide con \\c, \\1c, \\2c, \\3c, \\4c, pero no con \\clip (\u00a1importante!). (Tambi\u00e9n ten en cuenta que \\fs coincide con \\fsp y \\fscx, as\u00ed que ten cuidado con los patrones que pueden coincidir con cosas que no deseas). Dado que la primaria puede ser \\c o \\1c, para evitar c\u00f3digo complicado que trate con ambas, recomiendo usar esto al principio: text=text</p> <p>(\"\\1c&amp;\",\"\\c&amp;\") \\c es lo que la herramienta incorporada de Aegisub crea, as\u00ed que mant\u00e9n eso como est\u00e1ndar.</p> <p>Hablando de... trucos como este a menudo son muy \u00fatiles. Si tu c\u00f3digo necesita tener en cuenta muchas cosas diferentes, ve si puedes reducir el n\u00famero de estas cosas con alg\u00fan truco sencillo. Un problema com\u00fan es, por ejemplo, coincidir con el inicio de una palabra. Una palabra comienza ya sea despu\u00e9s de un espacio, o al principio de una l\u00ednea. Necesitas coincidir con dos patrones para eso. Sin embargo, puedes comenzar agregando un espacio al principio de una l\u00ednea, luego usa solo un patr\u00f3n de coincidencia, y luego elimina el espacio al final del script.</p> <p>Otra cosa es lidiar con l\u00edneas con y sin etiquetas (cuando trabajas con texto). Puedes comenzar con esto: tags=\"\" if text</p> <p>(\"\\^{\\[\\^}]}\") then tags=text</p> <p>(\"\\^({\\[\\^}]})\") end text=text</p> <p>(\"\\^{\\[\\^}]*}\",\"\")</p>"},{"location":"qc/qc/","title":"Revisi\u00f3n de Calidad","text":""},{"location":"sincronizacion/sincronizacion/","title":"Sincronizaci\u00f3n","text":""},{"location":"traduccion/traduccion/","title":"Traducci\u00f3n","text":"<p>To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed.</p>"}]}